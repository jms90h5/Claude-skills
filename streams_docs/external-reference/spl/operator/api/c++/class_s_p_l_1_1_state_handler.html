<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.14" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SPL Operator Runtime C++ API: SPL::StateHandler Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js">
</script>
    <script type="text/javascript" src="dynsections.js">
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
/*<![CDATA[*/
    address.c3 {align: right;}
    tr.c2 {height: 56px;}
    td.c1 {padding-left: 0.5em;}
    /*]]>*/
    </style>
</head>

<body>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->

        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr class="c2">
                        <td id="projectalign" class="c1">
                            <div id="projectname">
                                <a href="#main-content">SPL Operator Runtime C++ API &nbsp;<span id="projectnumber">7.2.0.1</span></a>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div><!-- end header part -->
        <!-- Generated by Doxygen 1.8.14 -->

        <div id="nav-path" class="navpath">
            <ul>
                <li class="navelem"><a class="el" href="namespace_s_p_l.html">SPL</a></li>

                <li class="navelem"><a class="el" href="class_s_p_l_1_1_state_handler.html">StateHandler</a></li>
            </ul>
        </div>
    </div><!-- top -->

    <div role="region" aria-label="Header Label" class="header">
        <div class="summary">
            <a href="#pub-methods">Public Member Functions</a> | <a href="class_s_p_l_1_1_state_handler-members.html">List of all members</a>
        </div>

        <div class="headertitle">
            <div class="title" id="main-content">
                SPL::StateHandler Class Reference
            </div>
        </div>
    </div><!--header-->

    <div role="main" class="contents">
        <p>Class that serves as a handler for operator state. The handler is<br />
        used when the operator is checkpointing or is in a consistent region. <a href="class_s_p_l_1_1_state_handler.html#details">More...</a></p>

        <p><code>#include &lt;SPL/Runtime/Operator/State/StateHandler.h&gt;</code></p>

        <table role="presentation" class="memberdecls">
            <tr class="heading">
                <td colspan="2">
                    <h2 class="groupheader"><a name="pub-methods" id="pub-methods"></a> Public Member Functions</h2>
                </td>
            </tr>

            <tr class="memitem:a8cdd73d87a6f7643167517290c47c132">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_state_handler.html#a8cdd73d87a6f7643167517290c47c132">drain</a> ()</td>
            </tr>

            <tr class="separator:a8cdd73d87a6f7643167517290c47c132">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a42470fa13921746bd688560219ce8392">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_state_handler.html#a42470fa13921746bd688560219ce8392">checkpoint</a> (<a class="el" href="class_s_p_l_1_1_checkpoint.html">Checkpoint</a> &amp;ckpt)</td>
            </tr>

            <tr class="separator:a42470fa13921746bd688560219ce8392">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a9c6bfc0d72ac097ec8cdb4f609519dc3">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_state_handler.html#a9c6bfc0d72ac097ec8cdb4f609519dc3">reset</a> (<a class="el" href="class_s_p_l_1_1_checkpoint.html">Checkpoint</a> &amp;ckpt)</td>
            </tr>

            <tr class="separator:a9c6bfc0d72ac097ec8cdb4f609519dc3">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:ab959a3dcf5436d062697f8baee7f6f1d">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_state_handler.html#ab959a3dcf5436d062697f8baee7f6f1d">retireCheckpoint</a> (int64_t id)</td>
            </tr>

            <tr class="separator:ab959a3dcf5436d062697f8baee7f6f1d">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:ace9ead44a8ad62abb170779ef199c66c">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_state_handler.html#ace9ead44a8ad62abb170779ef199c66c">resetToInitialState</a> ()</td>
            </tr>

            <tr class="separator:ace9ead44a8ad62abb170779ef199c66c">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a27494b7afbf3f8691925dabc7182511b">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_state_handler.html#a27494b7afbf3f8691925dabc7182511b">prepareForNonBlockingCheckpoint</a> (int64_t id)</td>
            </tr>

            <tr class="separator:a27494b7afbf3f8691925dabc7182511b">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a7bea6d91234a112407a97152c84bc454">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_state_handler.html#a7bea6d91234a112407a97152c84bc454">regionCheckpointed</a> (int64_t id)</td>
            </tr>

            <tr class="separator:a7bea6d91234a112407a97152c84bc454">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>
        </table><a name="details" id="details"></a>

        <h2 class="groupheader">Detailed Description</h2>

        <div class="textblock">
            <p>Class that serves as a handler for operator state. The handler is<br />
            used when the operator is checkpointing or is in a consistent region.</p>

            <p>If an operator is an instance of <a class="el" href="class_s_p_l_1_1_state_handler.html" title="Class that serves as a handler for operator state. The handler is used when the operator is checkpoi...">StateHandler</a> then it is automatically registered as a state handler, otherwise an operator registers an instance of <a class="el" href="class_s_p_l_1_1_state_handler.html" title="Class that serves as a handler for operator state. The handler is used when the operator is checkpoi...">StateHandler</a> using <a class="el" href="class_s_p_l_1_1_operator_context.html#a524158a3b9fd866bbf3d11c750052bb9">OperatorContext::registerStateHandler(StateHandler &amp;)</a>. Operators that need to manage state are encouraged to always utilize a <a class="el" href="class_s_p_l_1_1_state_handler.html" title="Class that serves as a handler for operator state. The handler is used when the operator is checkpoi...">StateHandler</a> by either extending <a class="el" href="class_s_p_l_1_1_state_handler.html" title="Class that serves as a handler for operator state. The handler is used when the operator is checkpoi...">StateHandler</a> or registering a state handler.</p>

            <p><a class="el" href="class_s_p_l_1_1_state_handler.html" title="Class that serves as a handler for operator state. The handler is used when the operator is checkpoi...">StateHandler</a> implementations should be careful to honor the contract of this interface to allow use in future scenarios. For example, no assumptions should be made about the operator being in a consistent region or checkpointing, and tuple submission should only occur from <a class="el" href="class_s_p_l_1_1_state_handler.html#a8cdd73d87a6f7643167517290c47c132">drain()</a>.</p>

            <p>When periodic checkpointing is enabled, the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime will call <a class="el" href="class_s_p_l_1_1_state_handler.html#a42470fa13921746bd688560219ce8392">checkpoint(Checkpoint&amp;)</a> for the registered state handler at the configured period. With operator driven checkpointing, the operator call <a class="el" href="class_s_p_l_1_1_checkpoint_context.html#a4614420e85b10f4f31da1e3105080a21">CheckpointContext::createCheckpoint()</a> to create a checkpoint, that will result in a callback to <a class="el" href="class_s_p_l_1_1_state_handler.html#a42470fa13921746bd688560219ce8392">checkpoint(Checkpoint&amp;)</a> for the registered handler. These callbacks occur on the thread that originated the create checkpoint request. After PE restart, the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime will reset the operator to a persisted state by calling <a class="el" href="class_s_p_l_1_1_state_handler.html#a9c6bfc0d72ac097ec8cdb4f609519dc3">reset(Checkpoint&amp;)</a> or <a class="el" href="class_s_p_l_1_1_state_handler.html#ace9ead44a8ad62abb170779ef199c66c">resetToInitialState()</a>.</p>

            <p>In a consistent region, the methods <a class="el" href="class_s_p_l_1_1_state_handler.html#a8cdd73d87a6f7643167517290c47c132">drain()</a> and <a class="el" href="class_s_p_l_1_1_state_handler.html#a42470fa13921746bd688560219ce8392">checkpoint(Checkpoint&amp;)</a> are periodically invoked, according to the consistent region configuration (periodic or operator-driven). On a <a class="el" href="class_s_p_l_1_1_state_handler.html#a8cdd73d87a6f7643167517290c47c132">drain()</a>, the operator must finish any outstanding processing related to tuples processed prior to the <a class="el" href="class_s_p_l_1_1_state_handler.html#a8cdd73d87a6f7643167517290c47c132">drain()</a> call. On a <a class="el" href="class_s_p_l_1_1_state_handler.html#a42470fa13921746bd688560219ce8392">checkpoint(Checkpoint&amp;)</a>, the operator can persist its state to the checkpointing backed. The persisted state is guaranteed to be consistent with the state of all other operators in the consistent region. After a failure of any operator in the region, the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime will reset the operator to the last successfully persisted consistent state by calling <a class="el" href="class_s_p_l_1_1_state_handler.html#a9c6bfc0d72ac097ec8cdb4f609519dc3">reset(Checkpoint&amp;)</a> or <a class="el" href="class_s_p_l_1_1_state_handler.html#ace9ead44a8ad62abb170779ef199c66c">resetToInitialState()</a>.</p>

            <p>If the operator code enables non-blocking checkpoint (via invoking <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#aca3d3b9955ae5ca94f2c49cc68d088fc">ConsistentRegionContext::enableNonBlockingCheckpoint()</a>), the <a class="el" href="class_s_p_l_1_1_state_handler.html#a27494b7afbf3f8691925dabc7182511b">prepareForNonBlockingCheckpoint(int64_t)</a> method is invoked by the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime after the <a class="el" href="class_s_p_l_1_1_state_handler.html#a8cdd73d87a6f7643167517290c47c132">drain()</a> method. The tuple flow is resumed after the return of <a class="el" href="class_s_p_l_1_1_state_handler.html#a27494b7afbf3f8691925dabc7182511b">prepareForNonBlockingCheckpoint(int64_t)</a> method. Meanwhile the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime delegates an internal thread to execute the operator's <a class="el" href="class_s_p_l_1_1_state_handler.html#a42470fa13921746bd688560219ce8392">checkpoint(Checkpoint&amp;)</a> method in the background. Background checkpointing is internally tracked by the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime.</p>

            <p>For a start operator of a consistent region, the <a class="el" href="class_s_p_l_1_1_state_handler.html#a7bea6d91234a112407a97152c84bc454">regionCheckpointed(int64_t)</a> method is called once all the operators in the consistent region is drained an checkpointed, including those operators performing non-blocking checkpointing.</p>
        </div>

        <h2 class="groupheader">Member Function Documentation</h2><a id="a8cdd73d87a6f7643167517290c47c132" name="a8cdd73d87a6f7643167517290c47c132"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a8cdd73d87a6f7643167517290c47c132">&#9670;&nbsp;</a></span>drain()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::StateHandler::drain</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Drain any outstanding processing. Once this method returns, the operator is indicating that it has drained all outstanding processing for all tuples seen on input ports. The method may: (i) submit tuples to output ports, (ii) interact with external systems, (iii) wait for background activity to drain outstanding work. For a consistent region this method is called once all this operator's data (non-control) input ports in the region have been drained. This method can be called concurrently with tuple and punctuation processing from autonomous ports and tuples from consistent control ports.</p>
            </div>
        </div><a id="a42470fa13921746bd688560219ce8392" name="a42470fa13921746bd688560219ce8392"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a42470fa13921746bd688560219ce8392">&#9670;&nbsp;</a></span>checkpoint()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::StateHandler::checkpoint</td>

                                    <td>(</td>

                                    <td class="paramtype"><a class="el" href="class_s_p_l_1_1_checkpoint.html">Checkpoint</a> &amp;&nbsp;</td>

                                    <td class="paramname"><em>ckpt</em></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p><a class="el" href="class_s_p_l_1_1_checkpoint.html" title="Class that represents an individual checkpoint i.e. a snapshot of the state of the operator when the ...">Checkpoint</a> the operator state. Serializing the operator state to the <a class="el" href="class_s_p_l_1_1_checkpoint.html" title="Class that represents an individual checkpoint i.e. a snapshot of the state of the operator when the ...">Checkpoint</a> reference ensures that the operator state is persisted to the Streams instance checkpoint backend.<br />
                If the operator is in a consistent region, the state is consistent with the checkpointed state of other operators in the same consistent region. If the operator is in a consistent region, this method is called after all consistent input ports (control and non-control) have been fully processed. It is guaranteed that no tuples or punctuations are processed by consistent or autonomous ports when this method is invoked.<br />
                No new tuples should be submitted during a checkpoint.</p>

                <dl class="params">
                    <dt>Parameters</dt>

                    <dd>
                        <table role="presentation" class="params">
                            <tr>
                                <td class="paramname">ckpt</td>

                                <td>reference to the checkpoint being created</td>
                            </tr>
                        </table>
                    </dd>
                </dl>
            </div>
        </div><a id="a9c6bfc0d72ac097ec8cdb4f609519dc3" name="a9c6bfc0d72ac097ec8cdb4f609519dc3"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a9c6bfc0d72ac097ec8cdb4f609519dc3">&#9670;&nbsp;</a></span>reset()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::StateHandler::reset</td>

                                    <td>(</td>

                                    <td class="paramtype"><a class="el" href="class_s_p_l_1_1_checkpoint.html">Checkpoint</a> &amp;&nbsp;</td>

                                    <td class="paramname"><em>ckpt</em></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Reset the operator state to a previously persisted operator state. Deserializing the operator from the checkpoint reference ensures that the operator state is restored from the Streams instance checkpoint backend.<br />
                If the operator is in a consistent region, the restored state is consistent with the restored state of other operators in the same consistent region. It is guaranteed that no tuples or punctuations are processed by consistent or autonomous ports when this method is invoked.<br />
                No new tuples should be submitted during a reset.</p>

                <dl class="params">
                    <dt>Parameters</dt>

                    <dd>
                        <table role="presentation" class="params">
                            <tr>
                                <td class="paramname">ckpt</td>

                                <td>reference to the checkpoint being reset</td>
                            </tr>
                        </table>
                    </dd>
                </dl>
            </div>
        </div><a id="ab959a3dcf5436d062697f8baee7f6f1d" name="ab959a3dcf5436d062697f8baee7f6f1d"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#ab959a3dcf5436d062697f8baee7f6f1d">&#9670;&nbsp;</a></span>retireCheckpoint()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::StateHandler::retireCheckpoint</td>

                                    <td>(</td>

                                    <td class="paramtype">int64_t&nbsp;</td>

                                    <td class="paramname"><em>id</em></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Retires a checkpoint with an given sequence identifier. When a checkpoint is retired, it means that the checkpoint with the provided sequence identifier will no longer be used on a reset in the lifetime of the job. There is no guarantee that this method is called for every retired checkpoint.<br />
                If the operator is in a consistent region and a checkpoint with a given id is retired, any checkpoint with an identifier equal or lower than the provided id is also retired. This method can be called concurrently with tuple and punctuation processing from autonomous and consistent ports.</p>

                <dl class="params">
                    <dt>Parameters</dt>

                    <dd>
                        <table role="presentation" class="params">
                            <tr>
                                <td class="paramname">id</td>

                                <td>checkpoint sequence id</td>
                            </tr>
                        </table>
                    </dd>
                </dl>
            </div>
        </div><a id="ace9ead44a8ad62abb170779ef199c66c" name="ace9ead44a8ad62abb170779ef199c66c"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#ace9ead44a8ad62abb170779ef199c66c">&#9670;&nbsp;</a></span>resetToInitialState()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::StateHandler::resetToInitialState</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Requests the operator to set its state to its state after <a class="el" href="class_s_p_l_1_1_operator.html#a673350bf6b0adff6d9223500c27df833">Operator::allPortsReady()</a> is invoked.<br />
                If the operator is in a consistent region, it is guaranteed that no tuples or punctuations are processed by consistent or autonomous ports when this method is invoked.<br />
                No new tuples should be submitted during a reset.</p>
            </div>
        </div><a id="a27494b7afbf3f8691925dabc7182511b" name="a27494b7afbf3f8691925dabc7182511b"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a27494b7afbf3f8691925dabc7182511b">&#9670;&nbsp;</a></span>prepareForNonBlockingCheckpoint()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::StateHandler::prepareForNonBlockingCheckpoint</td>

                                    <td>(</td>

                                    <td class="paramtype">int64_t&nbsp;</td>

                                    <td class="paramname"><em>id</em></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Prepare the operator for non-blocking checkpointing. This method is executed only when the operator enables non-blocking checkpointing with the <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#aca3d3b9955ae5ca94f2c49cc68d088fc">ConsistentRegionContext::enableNonBlockingCheckpoint()</a> method. This method is guaranteed to execute after <a class="el" href="class_s_p_l_1_1_state_handler.html#a8cdd73d87a6f7643167517290c47c132">StateHandler::drain()</a> and before <a class="el" href="class_s_p_l_1_1_state_handler.html#a42470fa13921746bd688560219ce8392">StateHandler::checkpoint()</a>. It is also guaranteed to execute before the consistent region resumed tuple processing.</p>

                <dl class="params">
                    <dt>Parameters</dt>

                    <dd>
                        <table role="presentation" class="params">
                            <tr>
                                <td class="paramname">id</td>

                                <td>checkpoint sequence id</td>
                            </tr>
                        </table>
                    </dd>
                </dl>

                <dl class="section since">
                    <dt>Since</dt>

                    <dd>Streams&reg; Version 4.2.0</dd>
                </dl>
            </div>
        </div><a id="a7bea6d91234a112407a97152c84bc454" name="a7bea6d91234a112407a97152c84bc454"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a7bea6d91234a112407a97152c84bc454">&#9670;&nbsp;</a></span>regionCheckpointed()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::StateHandler::regionCheckpointed</td>

                                    <td>(</td>

                                    <td class="paramtype">int64_t&nbsp;</td>

                                    <td class="paramname"><em>id</em></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Notify that the whole consistent region has been drained and checkpointed. When all operators in a consistent region have completed checkpointing (including non-blocking checkpointing), the <a class="el" href="class_s_p_l_1_1_state_handler.html#a7bea6d91234a112407a97152c84bc454">regionCheckpointed()</a> method is called to notify each start operator of the region.<br />
                This method is called only for start operators of a consistent region.<br /></p>

                <dl class="params">
                    <dt>Parameters</dt>

                    <dd>
                        <table role="presentation" class="params">
                            <tr>
                                <td class="paramname">id</td>

                                <td>checkpoint sequence id</td>
                            </tr>
                        </table>
                    </dd>
                </dl>

                <dl class="section since">
                    <dt>Since</dt>

                    <dd>Streams&reg; Version 4.2.0</dd>
                </dl>
            </div>
        </div>
        <hr />
        The documentation for this class was generated from the following file:

        <ul>
            <li>SPL/Runtime/Operator/State/<a class="el" href="_state_handler_8h.html">StateHandler.h</a></li>
        </ul>
    </div><!-- contents -->
    <!-- begin_generated_IBM_Teracloud_ApS_copyright_prolog               -->
    <!--                                                                  -->
    <!-- This is an automatically generated copyright prolog.             -->
    <!-- After initializing,  DO NOT MODIFY OR MOVE                       -->
    <!-- **************************************************************** -->
    <!-- Licensed Materials - Property of IBM                             -->
    <!-- (C) Copyright Teracloud ApS 2024, 2024, IBM Corp. 2010, 2016     -->
    <!-- All Rights Reserved.                                             -->
    <!-- US Government Users Restricted Rights - Use, duplication or      -->
    <!-- disclosure restricted by GSA ADP Schedule Contract with          -->
    <!-- IBM Corp.                                                        -->
    <!--                                                                  -->
    <!-- end_generated_IBM_Teracloud_ApS_copyright_prolog                 -->
    <hr size="1" />

    <address class="c3">
        <span class="small">Streams</span>
    </address>
</body>
</html>
