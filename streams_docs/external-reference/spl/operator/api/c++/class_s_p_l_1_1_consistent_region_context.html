<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.14" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SPL Operator Runtime C++ API: SPL::ConsistentRegionContext Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js">
</script>
    <script type="text/javascript" src="dynsections.js">
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
/*<![CDATA[*/
    address.c4 {align: right;}
    div.c3 {text-align: center}
    tr.c2 {height: 56px;}
    td.c1 {padding-left: 0.5em;}
    /*]]>*/
    </style>
</head>

<body>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->

        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr class="c2">
                        <td id="projectalign" class="c1">
                            <div id="projectname">
                                <a href="#main-content">SPL Operator Runtime C++ API &nbsp;<span id="projectnumber">7.2.0.1</span></a>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div><!-- end header part -->
        <!-- Generated by Doxygen 1.8.14 -->

        <div id="nav-path" class="navpath">
            <ul>
                <li class="navelem"><a class="el" href="namespace_s_p_l.html">SPL</a></li>

                <li class="navelem"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html">ConsistentRegionContext</a></li>
            </ul>
        </div>
    </div><!-- top -->

    <div role="region" aria-label="Header Label" class="header">
        <div class="summary">
            <a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_s_p_l_1_1_consistent_region_context-members.html">List of all members</a>
        </div>

        <div class="headertitle">
            <div class="title" id="main-content">
                SPL::ConsistentRegionContext Class Reference<span class="mlabels mlabel">abstract</span>
            </div>
        </div>
    </div><!--header-->

    <div role="main" class="contents">
        <p>This is an optional context that can be acquired by using the CONSISTENT_REGION string defined in <a class="el" href="class_s_p_l_1_1_optional_context.html" title="Class that serves as a base for all optional operator contexts. ">OptionalContext</a>. An operator has a <a class="el" href="class_s_p_l_1_1_consistent_region_context.html" title="This is an optional context that can be acquired by using the CONSISTENT_REGION string defined in Opt...">ConsistentRegionContext</a> when it belongs to a consistent region. <a href="class_s_p_l_1_1_consistent_region_context.html#details">More...</a></p>

        <p><code>#include &lt;SPL/Runtime/Operator/State/ConsistentRegionContext.h&gt;</code></p>

        <div class="dynheader">
            Inheritance diagram for SPL::ConsistentRegionContext:
        </div>

        <div class="dyncontent">
            <div class="center"><img src="class_s_p_l_1_1_consistent_region_context__inherit__graph.png" border="0" usemap="#_s_p_l_1_1_consistent_region_context_inherit__map" alt="Inheritance graph" /></div><map name="_s_p_l_1_1_consistent_region_context_inherit__map" id="_s_p_l_1_1_consistent_region_context_inherit__map">
                <area shape="rect" id="node2" href="class_s_p_l_1_1_optional_context.html" title="Class that serves as a base for all optional operator contexts. " alt="node" coords="33,5,183,32" />
            </map>

            <div class="c3">
                <span class="legend">[<a href="graph_legend.html">legend</a>]</span>
            </div>
        </div>

        <table role="presentation" class="memberdecls">
            <tr class="heading">
                <td colspan="2">
                    <h2 class="groupheader"><a name="pub-types" id="pub-types"></a> Public Types</h2>
                </td>
            </tr>

            <tr class="memitem:abdbd391b7398dc294ca3ebdfe6a2e551">
                <td class="memItemLeft" align="right" valign="top">enum &nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#abdbd391b7398dc294ca3ebdfe6a2e551">DrainResult</a> { <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#abdbd391b7398dc294ca3ebdfe6a2e551a8b3ee1a2b2b796bab587421eda70a42a">COMPLETED</a>, <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#abdbd391b7398dc294ca3ebdfe6a2e551aab5dc6310bc3f228a7f582e4788b96b2">CHECKPOINT_PENDING</a>, <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#abdbd391b7398dc294ca3ebdfe6a2e551a28586d5c2d1842a37cd11ca908f19829">FAILED</a> }</td>
            </tr>

            <tr class="separator:abdbd391b7398dc294ca3ebdfe6a2e551">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>
        </table>

        <table role="presentation" class="memberdecls">
            <tr class="heading">
                <td colspan="2">
                    <h2 class="groupheader"><a name="pub-methods" id="pub-methods"></a> Public Member Functions</h2>
                </td>
            </tr>

            <tr class="memitem:aedb81788be401d4e85c89c09a7f950e3">
                <td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#aedb81788be401d4e85c89c09a7f950e3">isStartOfRegion</a> () const =0</td>
            </tr>

            <tr class="separator:aedb81788be401d4e85c89c09a7f950e3">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a9f45c023abed6987bd6e964e3154566c">
                <td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a9f45c023abed6987bd6e964e3154566c">isEndOfRegion</a> () const =0</td>
            </tr>

            <tr class="separator:a9f45c023abed6987bd6e964e3154566c">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a92482ac3155ce96cb5f90c2212c99de2">
                <td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a92482ac3155ce96cb5f90c2212c99de2">isTriggerOperator</a> () const =0</td>
            </tr>

            <tr class="separator:a92482ac3155ce96cb5f90c2212c99de2">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a337b448b3cd8fe1221770ea5fb1cfd63">
                <td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a337b448b3cd8fe1221770ea5fb1cfd63">isConsistentInputPort</a> (uint32_t port) const =0</td>
            </tr>

            <tr class="separator:a337b448b3cd8fe1221770ea5fb1cfd63">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a11b4a5c31d8962aca4c234d2ec2a5d34">
                <td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="class_s_p_l_1_1_operator_input_port.html">OperatorInputPort</a> * &gt;&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a11b4a5c31d8962aca4c234d2ec2a5d34">getInputPorts</a> () const =0</td>
            </tr>

            <tr class="separator:a11b4a5c31d8962aca4c234d2ec2a5d34">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:ac35ba0c0ce4a1246ff1d6580798c513e">
                <td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#ac35ba0c0ce4a1246ff1d6580798c513e">getIndex</a> () const =0</td>
            </tr>

            <tr class="separator:ac35ba0c0ce4a1246ff1d6580798c513e">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:aa609ac44b5582a6751d9329a39899673">
                <td class="memItemLeft" align="right" valign="top">virtual std::string const &amp;&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#aa609ac44b5582a6751d9329a39899673">getConsistentRegionMXBeanName</a> () const =0</td>
            </tr>

            <tr class="separator:aa609ac44b5582a6751d9329a39899673">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a5e22c16c433a2b016ebad32e2f2d4739">
                <td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a5e22c16c433a2b016ebad32e2f2d4739">getSequenceId</a> () const =0</td>
            </tr>

            <tr class="separator:a5e22c16c433a2b016ebad32e2f2d4739">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a92282096ef8bab08848fee11ad3c372f">
                <td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a92282096ef8bab08848fee11ad3c372f">getResetAttempt</a> () const =0</td>
            </tr>

            <tr class="separator:a92282096ef8bab08848fee11ad3c372f">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a0f21bd2350181edf126e1437fb03e1e6">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a0f21bd2350181edf126e1437fb03e1e6">resetRegion</a> ()=0</td>
            </tr>

            <tr class="separator:a0f21bd2350181edf126e1437fb03e1e6">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a4bedc4c65c287d18054eb6e17ea32839">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a4bedc4c65c287d18054eb6e17ea32839">acquirePermit</a> ()=0</td>
            </tr>

            <tr class="separator:a4bedc4c65c287d18054eb6e17ea32839">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:abd2737f2bb2cde362c3588dbf3d18e76">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#abd2737f2bb2cde362c3588dbf3d18e76">releasePermit</a> ()=0</td>
            </tr>

            <tr class="separator:abd2737f2bb2cde362c3588dbf3d18e76">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a954cf04340367f0ff9c7b32602527bf1">
                <td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent</a> ()=0</td>
            </tr>

            <tr class="separator:a954cf04340367f0ff9c7b32602527bf1">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a43a220fd8daeeff37030dbd945a62065">
                <td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a43a220fd8daeeff37030dbd945a62065">getDrainTimeout</a> ()=0</td>
            </tr>

            <tr class="separator:a43a220fd8daeeff37030dbd945a62065">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a02f32366f239751b02712afa364a5f35">
                <td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a02f32366f239751b02712afa364a5f35">getResetTimeout</a> ()=0</td>
            </tr>

            <tr class="separator:a02f32366f239751b02712afa364a5f35">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:aca3d3b9955ae5ca94f2c49cc68d088fc">
                <td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#aca3d3b9955ae5ca94f2c49cc68d088fc">enableNonBlockingCheckpoint</a> ()=0</td>
            </tr>

            <tr class="separator:aca3d3b9955ae5ca94f2c49cc68d088fc">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="memitem:a8f19774ff93e0b2f119bc2a8414d2f3b">
                <td class="memItemLeft" align="right" valign="top">virtual enum <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#abdbd391b7398dc294ca3ebdfe6a2e551">DrainResult</a>&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking</a> ()=0</td>
            </tr>

            <tr class="separator:a8f19774ff93e0b2f119bc2a8414d2f3b">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>

            <tr class="inherit_header pub_methods_class_s_p_l_1_1_optional_context">
                <td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_s_p_l_1_1_optional_context')"><img src="closed.png" alt="-" />&nbsp;Public Member Functions inherited from <a class="el" href="class_s_p_l_1_1_optional_context.html">SPL::OptionalContext</a></td>
            </tr>

            <tr class="memitem:a02ec0d84cbdb9cabe0ea7d264900f3d8 inherit pub_methods_class_s_p_l_1_1_optional_context">
                <td class="memItemLeft" align="right" valign="top">virtual std::string const &amp;&nbsp;</td>

                <td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_l_1_1_optional_context.html#a02ec0d84cbdb9cabe0ea7d264900f3d8">getName</a> () const =0</td>
            </tr>

            <tr class="separator:a02ec0d84cbdb9cabe0ea7d264900f3d8 inherit pub_methods_class_s_p_l_1_1_optional_context">
                <td class="memSeparator" colspan="2">&nbsp;</td>
            </tr>
        </table><a name="details" id="details"></a>

        <h2 class="groupheader">Detailed Description</h2>

        <div class="textblock">
            <p>This is an optional context that can be acquired by using the CONSISTENT_REGION string defined in <a class="el" href="class_s_p_l_1_1_optional_context.html" title="Class that serves as a base for all optional operator contexts. ">OptionalContext</a>. An operator has a <a class="el" href="class_s_p_l_1_1_consistent_region_context.html" title="This is an optional context that can be acquired by using the CONSISTENT_REGION string defined in Opt...">ConsistentRegionContext</a> when it belongs to a consistent region.</p>

            <p>One can use the @consistent annotation to define a consistent region. Consistent regions enable an application to achieve guaranteed tuple processing.</p>
        </div>

        <h2 class="groupheader">Member Enumeration Documentation</h2><a id="abdbd391b7398dc294ca3ebdfe6a2e551" name="abdbd391b7398dc294ca3ebdfe6a2e551"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#abdbd391b7398dc294ca3ebdfe6a2e551">&#9670;&nbsp;</a></span>DrainResult</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="memname">
                    <tr>
                        <td class="memname">enum <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#abdbd391b7398dc294ca3ebdfe6a2e551">SPL::ConsistentRegionContext::DrainResult</a></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Return value of <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> call</p>

                <dl class="section since">
                    <dt>Since</dt>

                    <dd>Streams&reg; Version 4.2.0</dd>
                </dl>

                <table class="fieldtable">
                    <tr>
                        <th colspan="2">Enumerator</th>
                    </tr>

                    <tr>
                        <td class="fieldname"><a id="abdbd391b7398dc294ca3ebdfe6a2e551a8b3ee1a2b2b796bab587421eda70a42a" name="abdbd391b7398dc294ca3ebdfe6a2e551a8b3ee1a2b2b796bab587421eda70a42a"></a>COMPLETED&nbsp;</td>

                        <td class="fielddoc"></td>
                    </tr>

                    <tr>
                        <td class="fieldname"><a id="abdbd391b7398dc294ca3ebdfe6a2e551aab5dc6310bc3f228a7f582e4788b96b2" name="abdbd391b7398dc294ca3ebdfe6a2e551aab5dc6310bc3f228a7f582e4788b96b2"></a>CHECKPOINT_PENDING&nbsp;</td>

                        <td class="fielddoc"></td>
                    </tr>

                    <tr>
                        <td class="fieldname"><a id="abdbd391b7398dc294ca3ebdfe6a2e551a28586d5c2d1842a37cd11ca908f19829" name="abdbd391b7398dc294ca3ebdfe6a2e551a28586d5c2d1842a37cd11ca908f19829"></a>FAILED&nbsp;</td>

                        <td class="fielddoc"></td>
                    </tr>
                </table>
            </div>
        </div>

        <h2 class="groupheader">Member Function Documentation</h2><a id="aedb81788be401d4e85c89c09a7f950e3" name="aedb81788be401d4e85c89c09a7f950e3"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#aedb81788be401d4e85c89c09a7f950e3">&#9670;&nbsp;</a></span>isStartOfRegion()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual bool SPL::ConsistentRegionContext::isStartOfRegion</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td>const</td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Checks if the operator is a start of a consistent region.</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>true if the operator is a start of a consistent region, false otherwise</dd>
                </dl>
            </div>
        </div><a id="a9f45c023abed6987bd6e964e3154566c" name="a9f45c023abed6987bd6e964e3154566c"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a9f45c023abed6987bd6e964e3154566c">&#9670;&nbsp;</a></span>isEndOfRegion()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual bool SPL::ConsistentRegionContext::isEndOfRegion</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td>const</td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Checks if the operator is an end of a consistent region</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>true if the operator is an end of a consistent region, false otherwise</dd>
                </dl>
            </div>
        </div><a id="a92482ac3155ce96cb5f90c2212c99de2" name="a92482ac3155ce96cb5f90c2212c99de2"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a92482ac3155ce96cb5f90c2212c99de2">&#9670;&nbsp;</a></span>isTriggerOperator()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual bool SPL::ConsistentRegionContext::isTriggerOperator</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td>const</td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Checks if the operator is the trigger operator of a consistent region. An operator is the trigger operator if it is the start operator of an operator-driven region.</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>true if the operator is the trigger operator of a consistent region, false otherwise</dd>
                </dl>
            </div>
        </div><a id="a337b448b3cd8fe1221770ea5fb1cfd63" name="a337b448b3cd8fe1221770ea5fb1cfd63"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a337b448b3cd8fe1221770ea5fb1cfd63">&#9670;&nbsp;</a></span>isConsistentInputPort()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual bool SPL::ConsistentRegionContext::isConsistentInputPort</td>

                                    <td>(</td>

                                    <td class="paramtype">uint32_t&nbsp;</td>

                                    <td class="paramname"><em>port</em></td>

                                    <td>)</td>

                                    <td>const</td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Checks if the operator input port is part of the consistent region. An input port is part of a consistent region if it consumes streams from other operators that are also in the consistent region.</p>

                <dl class="params">
                    <dt>Parameters</dt>

                    <dd>
                        <table role="presentation" class="params">
                            <tr>
                                <td class="paramname">port</td>

                                <td>input port index</td>
                            </tr>
                        </table>
                    </dd>
                </dl>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>true if the port is part of the consistent region, false otherwise</dd>
                </dl>

                <dl class="exception">
                    <dt>Exceptions</dt>

                    <dd>
                        <table role="presentation" class="exception">
                            <tr>
                                <td class="paramname"><a class="el" href="class_s_p_l_1_1_s_p_l_runtime_invalid_index_exception.html" title="Class that represents SPL runtime invalid index exceptions. ">SPLRuntimeInvalidIndexException</a></td>

                                <td>when the index is out of bounds</td>
                            </tr>
                        </table>
                    </dd>
                </dl>
            </div>
        </div><a id="a11b4a5c31d8962aca4c234d2ec2a5d34" name="a11b4a5c31d8962aca4c234d2ec2a5d34"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a11b4a5c31d8962aca4c234d2ec2a5d34">&#9670;&nbsp;</a></span>getInputPorts()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual std::vector&lt;<a class="el" href="class_s_p_l_1_1_operator_input_port.html">OperatorInputPort</a> *&gt; SPL::ConsistentRegionContext::getInputPorts</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td>const</td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Gets the input ports that participate in the consistent region</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>vector with pointers to all input ports that participate in the consistent region</dd>
                </dl>
            </div>
        </div><a id="ac35ba0c0ce4a1246ff1d6580798c513e" name="ac35ba0c0ce4a1246ff1d6580798c513e"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#ac35ba0c0ce4a1246ff1d6580798c513e">&#9670;&nbsp;</a></span>getIndex()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual int32_t SPL::ConsistentRegionContext::getIndex</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td>const</td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Get the region index</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>region index</dd>
                </dl>
            </div>
        </div><a id="aa609ac44b5582a6751d9329a39899673" name="aa609ac44b5582a6751d9329a39899673"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#aa609ac44b5582a6751d9329a39899673">&#9670;&nbsp;</a></span>getConsistentRegionMXBeanName()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual std::string const&amp; SPL::ConsistentRegionContext::getConsistentRegionMXBeanName</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td>const</td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Get the canonical form of the ObjectName of the <code>ConsistentRegionMXBean</code> associated with the current consistent region. The name can be used to identify the source of notifications to subscribe to.</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>canonical form for the <code>ConsistentRegionMXBean</code> ObjectName</dd>
                </dl>
            </div>
        </div><a id="a5e22c16c433a2b016ebad32e2f2d4739" name="a5e22c16c433a2b016ebad32e2f2d4739"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a5e22c16c433a2b016ebad32e2f2d4739">&#9670;&nbsp;</a></span>getSequenceId()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual int64_t SPL::ConsistentRegionContext::getSequenceId</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td>const</td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>This method returns the current sequence identifier of a consistent region. It indicates the id that a drain or a reset should be associated to. After operator startup, this method returns 1. On operator restart, the method returns -1 until it has reset.<br />
                When establishing a consistent state, the sequence ID is strictly increasing. When resetting, the sequence ID refers to a sequence ID of a prior successfully established consistent state.</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>current sequence id of a drain or reset, or -1 if the method is accessed after the operator restarts due to a PE crash but before the operator resets</dd>
                </dl>
            </div>
        </div><a id="a92282096ef8bab08848fee11ad3c372f" name="a92282096ef8bab08848fee11ad3c372f"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a92282096ef8bab08848fee11ad3c372f">&#9670;&nbsp;</a></span>getResetAttempt()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual int32_t SPL::ConsistentRegionContext::getResetAttempt</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td>const</td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Returns the current number of attempts of resetting a consistent region. If a drain is completed after a reset, this method returns -1.</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>last reset attempt, or -1 if a drain has been successfully processed after a reset</dd>
                </dl>
            </div>
        </div><a id="a0f21bd2350181edf126e1437fb03e1e6" name="a0f21bd2350181edf126e1437fb03e1e6"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a0f21bd2350181edf126e1437fb03e1e6">&#9670;&nbsp;</a></span>resetRegion()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::ConsistentRegionContext::resetRegion</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Requests the <code>ConsistentRegionMXBean</code> to reset the consistent region to the point of the last successful drain. If the region is already being reset, a new reset attempt is triggered. This method can be used by operators when detecting an operator-specific transient failure (e.g., handling an exception that prevents the successful establishment of a consistent state). If the exception happens while holding consistent region permits, this method must be invoked while holding the permit.</p>
            </div>
        </div><a id="a4bedc4c65c287d18054eb6e17ea32839" name="a4bedc4c65c287d18054eb6e17ea32839"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a4bedc4c65c287d18054eb6e17ea32839">&#9670;&nbsp;</a></span>acquirePermit()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::ConsistentRegionContext::acquirePermit</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Acquires the permit required to do operator state modification and tuple or punctuation submission in a consistent region.<br />
                Once the permit is acquired, no consistent state is established or reset until the permit is released. If a consistent state is being established or reset, this method blocks until the process completes successfuly.<br />
                Multiple threads are allowed to acquire permits at the same time. <a class="el" href="class_s_p_l_1_1_operator.html" title="Class that serves as the base class of all SPL primitive operators. ">Operator</a> backgrounds threads (e.g., threads running <a class="el" href="class_s_p_l_1_1_operator.html#ad7f9949494255dca2aac7f1385f39d00">Operator::process(uint32_t)</a>) that perform tuple or punctuation submission must always acquire permits prior to submission. Permits are automatically acquired by the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> runtime when processing tuples (e.g., <a class="el" href="class_s_p_l_1_1_operator.html#aecb39efe7afedb56c5edcb6b2d9690ba">Operator::process(Tuple &amp;, uint32_t)</a>), punctuations (<a class="el" href="class_s_p_l_1_1_operator.html#ae8dc154049eba18e7deb07334d524485">Operator::process(Punctuation const &amp;, uint32_t)</a>), and window library events.</p>
            </div>
        </div><a id="abd2737f2bb2cde362c3588dbf3d18e76" name="abd2737f2bb2cde362c3588dbf3d18e76"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#abd2737f2bb2cde362c3588dbf3d18e76">&#9670;&nbsp;</a></span>releasePermit()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::ConsistentRegionContext::releasePermit</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Releases a previously acquired permit. Releasing a permit indicates the successful completion of operator state modification and tuple or punctuation submission, unless the <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a0f21bd2350181edf126e1437fb03e1e6">resetRegion()</a> method has been invoked prior to the release of the permit.</p>
            </div>
        </div><a id="a954cf04340367f0ff9c7b32602527bf1" name="a954cf04340367f0ff9c7b32602527bf1"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a954cf04340367f0ff9c7b32602527bf1">&#9670;&nbsp;</a></span>makeConsistent()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual bool SPL::ConsistentRegionContext::makeConsistent</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Called by start operators of a region to initiate the establishment of a consistent state. If the region is operator driven, and the operator is the trigger operator of the region, draining of the region starts immediately. If the region is periodic, the calling thread blocks until the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> runtime finishes the next periodic consistent state. If the operator needs to submit more tuples prior to the start of a consistent state, such tuples can be submitted in the <a class="el" href="class_s_p_l_1_1_state_handler.html#a8cdd73d87a6f7643167517290c47c132">StateHandler::drain()</a> method.<br />
                To successfully execute <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent()</a>, the calling thread must currently hold a permit. If multiple threads call this method at the same time, only a single consistent state will be established.<br />
                The method blocks the calling thread and returns when the region has successfully established or reset a consistent state or when there is a shutdown request.<br />
                Note that calling <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent()</a> in the start operator would block the tuple flow until all operators in the consistent region have finished checkpointing, including those operator which enable non-blocking checkpointing. In order to achieve non-blocking checkpointing, please use <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> in the start operator.<br />
                Since Streams&reg; Version 4.2.0, before <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent()</a> returns true, the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime invokes start operator's <a class="el" href="class_s_p_l_1_1_state_handler.html#a7bea6d91234a112407a97152c84bc454">StateHandler::regionCheckpointed()</a> callback.<br /></p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>true if the region become consistent without any reset, false otherwise.</dd>
                </dl>

                <dl class="exception">
                    <dt>Exceptions</dt>

                    <dd>
                        <table role="presentation" class="exception">
                            <tr>
                                <td class="paramname"><a class="el" href="class_s_p_l_1_1_s_p_l_runtime_operator_exception.html" title="Class that represents SPL runtime operator exceptions. ">SPLRuntimeOperatorException</a></td>

                                <td>if the operator is not a start operator of the region.</td>
                            </tr>
                        </table>
                    </dd>
                </dl>
            </div>
        </div><a id="a43a220fd8daeeff37030dbd945a62065" name="a43a220fd8daeeff37030dbd945a62065"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a43a220fd8daeeff37030dbd945a62065">&#9670;&nbsp;</a></span>getDrainTimeout()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual double SPL::ConsistentRegionContext::getDrainTimeout</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Gets the drain timeout of the consistent region</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>timeout specified drain timeout for the region</dd>
                </dl>

                <dl class="section since">
                    <dt>Since</dt>

                    <dd>InfoSphere&reg; Streams Version 4.0.1</dd>
                </dl>
            </div>
        </div><a id="a02f32366f239751b02712afa364a5f35" name="a02f32366f239751b02712afa364a5f35"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a02f32366f239751b02712afa364a5f35">&#9670;&nbsp;</a></span>getResetTimeout()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual double SPL::ConsistentRegionContext::getResetTimeout</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Gets the reset timeout of the consistent region</p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>timeout specified reset timeout for the region</dd>
                </dl>

                <dl class="section since">
                    <dt>Since</dt>

                    <dd>InfoSphere&reg; Streams Version 4.0.1</dd>
                </dl>
            </div>
        </div><a id="aca3d3b9955ae5ca94f2c49cc68d088fc" name="aca3d3b9955ae5ca94f2c49cc68d088fc"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#aca3d3b9955ae5ca94f2c49cc68d088fc">&#9670;&nbsp;</a></span>enableNonBlockingCheckpoint()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual void SPL::ConsistentRegionContext::enableNonBlockingCheckpoint</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Enables non-blocking checkpointing. This method must be invoked from the operator constructor. Non-blocking checkpointing enables an operator to checkpoint its state while new tuples are processed. This should be used only when the operator implements techniques that guarantee that the operator state saved on the checkpoint() call is consistent with processing all tuples prior to the drain() call even after tuple processing is resumed. One such technique<br />
                is user-level copy-on-write of operator state.</p>

                <dl class="section since">
                    <dt>Since</dt>

                    <dd>Streams&reg; Version 4.2.0</dd>
                </dl>
            </div>
        </div><a id="a8f19774ff93e0b2f119bc2a8414d2f3b" name="a8f19774ff93e0b2f119bc2a8414d2f3b"></a>

        <h2 class="memtitle"><span class="permalink"><a href="#a8f19774ff93e0b2f119bc2a8414d2f3b">&#9670;&nbsp;</a></span>makeConsistentNonBlocking()</h2>

        <div class="memitem">
            <div class="memproto">
                <table role="presentation" class="mlabels">
                    <tr>
                        <td class="mlabels-left">
                            <table role="presentation" class="memname">
                                <tr>
                                    <td class="memname">virtual enum <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#abdbd391b7398dc294ca3ebdfe6a2e551">DrainResult</a> SPL::ConsistentRegionContext::makeConsistentNonBlocking</td>

                                    <td>(</td>

                                    <td class="paramname"></td>

                                    <td>)</td>

                                    <td></td>
                                </tr>
                            </table>
                        </td>

                        <td class="mlabels-right"><span class="mlabels mlabel">pure virtual</span></td>
                    </tr>
                </table>
            </div>

            <div class="memdoc">
                <p>Called by start operators of a region to initiate the establishment of a consistent state. If the region is operator driven, and the operator is the trigger operator of the region, draining of the region starts immediately. If the region is periodic, the calling thread blocks until the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> runtime starts the next periodic consistent state. If the operator needs to submit more tuples prior to the start of a consistent state, such tuples can be submitted in the <a class="el" href="class_s_p_l_1_1_state_handler.html#a8cdd73d87a6f7643167517290c47c132">StateHandler::drain()</a> method.<br />
                To successfully execute <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a>, the thread must currently hold a permit. If multiple threads call this method at the same time, only a single consistent state will be established.<br />
                The <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> function has similar functionality as <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent()</a>, but should be preferred when the consistent region contains operator(s) with non-blocking checkpoointing enabled.<br />
                If a consistent region has no operator which enables non-blocking checkpointing, then the <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> returns COMPLETED when a consistent state has successfully established, or FAILED when there is a shutdown request or there is a failure and the region has been resetted. So if the consistent region has no operator with non-blocking checkpointing enabled, <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> returning COMPLETED is equivalent to <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent()</a> returning true, and <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> returning FAILED is the same as <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent()</a> returning false.<br />
                If a consistent region has any operator which enabls non-blocking checkpointing, then the <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> may also return CHECKPOINT_PENDING, indicating that all blocking operators have finished checkpointing and all non-blocking operators have finished preparation but there is still non-blocking checkpointing ongoing. The start operator can resume tuple processing upon the return of CHECKPOINT_PENDING. In comparison, if <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent()</a> is used when the consistent region has any operator with non-blocking checkpointing enabled, the <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent()</a> call would not return until all operator have finished checkpointing (including those non-blocking ones).<br />
                If <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> returns COMPLETED (no matter whether there is non-blocking operator in the region), a consistent state has been successfully established, and it is safe to resume tuple processing and retire any tuples between this checkpoint and the previous checkpoint. The previous checkpoint has also been retired by the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime via calling <a class="el" href="class_s_p_l_1_1_state_handler.html#ab959a3dcf5436d062697f8baee7f6f1d">StateHandler::retireCheckpoint()</a>. Before letting makeConsistentNonblocking() returning COMPLETED, the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime also invokes start operator's <a class="el" href="class_s_p_l_1_1_state_handler.html#a7bea6d91234a112407a97152c84bc454">StateHandler::regionCheckpointed()</a> callback.<br />
                If <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> returns CHECKPOINT_PENDING, it is not safe to retire tuples between this checkpoint and the previous checkpoint, and the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime has not yet retired the previous checkpoint; however, it is ok to resume tuple processing after CHECKPOINT_PENDING is returned. When all the pending checkpoints are complete, the <a class="el" href="namespace_s_p_l.html" title="C++ classes for writing operators. ">SPL</a> Runtime invokes start operator's <a class="el" href="class_s_p_l_1_1_state_handler.html#a7bea6d91234a112407a97152c84bc454">StateHandler::regionCheckpointed()</a> callback.<br />
                <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a8f19774ff93e0b2f119bc2a8414d2f3b">makeConsistentNonBlocking()</a> and <a class="el" href="class_s_p_l_1_1_consistent_region_context.html#a954cf04340367f0ff9c7b32602527bf1">makeConsistent()</a> cannot be used in mix.<br /></p>

                <dl class="section return">
                    <dt>Returns</dt>

                    <dd>COMPLETED if all operators have finished checkponting, return CHECKPOINT_PENDING if all operators that do blocking checkpointing have finished checkpointing, andall operators that do non-blocking checkpointing have finished preparation for non-blocking checkpointing, but at least one operator still has non-blocking checkpointing ongoing, return FAILED if there is failure &amp; reset or shutdown request during the draining and checkpointing process</dd>
                </dl>

                <dl class="exception">
                    <dt>Exceptions</dt>

                    <dd>
                        <table role="presentation" class="exception">
                            <tr>
                                <td class="paramname"><a class="el" href="class_s_p_l_1_1_s_p_l_runtime_operator_exception.html" title="Class that represents SPL runtime operator exceptions. ">SPLRuntimeOperatorException</a></td>

                                <td>if the operator is not a start operator of the region.</td>
                            </tr>
                        </table>
                    </dd>
                </dl>

                <dl class="section since">
                    <dt>Since</dt>

                    <dd>Streams&reg; Version 4.2.0</dd>
                </dl>
            </div>
        </div>
        <hr />
        The documentation for this class was generated from the following file:

        <ul>
            <li>SPL/Runtime/Operator/State/<a class="el" href="_consistent_region_context_8h.html">ConsistentRegionContext.h</a></li>
        </ul>
    </div><!-- contents -->
    <!-- begin_generated_IBM_Teracloud_ApS_copyright_prolog               -->
    <!--                                                                  -->
    <!-- This is an automatically generated copyright prolog.             -->
    <!-- After initializing,  DO NOT MODIFY OR MOVE                       -->
    <!-- **************************************************************** -->
    <!-- Licensed Materials - Property of IBM                             -->
    <!-- (C) Copyright Teracloud ApS 2024, 2024, IBM Corp. 2010, 2016     -->
    <!-- All Rights Reserved.                                             -->
    <!-- US Government Users Restricted Rights - Use, duplication or      -->
    <!-- disclosure restricted by GSA ADP Schedule Contract with          -->
    <!-- IBM Corp.                                                        -->
    <!--                                                                  -->
    <!-- end_generated_IBM_Teracloud_ApS_copyright_prolog                 -->
    <hr size="1" />

    <address class="c4">
        <span class="small">Streams</span>
    </address>
</body>
</html>
