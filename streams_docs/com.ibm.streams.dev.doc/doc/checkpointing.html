<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" data-whc_version="22.0">
    <head><link rel="shortcut icon" href="../../favicon-light.png"/><link rel="icon" href="../../favicon-light.png"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="DC.rights.owner" content="(C) Copyright 2025"/><meta name="copyright" content="(C) Copyright 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="description" content="Checkpointing is the process of persisting operator state at run time to allow recovery from a failure. In case of failure, the operator can be restarted by resetting from the checkpointed state."/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/advancedoperatorimplementationtopics.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/dev-container.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/developing_operators.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/developing_primitive_operators.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/creatingprimitiveoperators.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/implementingoperators.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/consistentregions.html"/><meta name="DC.relation" content="../../com.ibm.streams.cfg.doc/doc/ibminfospherestreams-configuring-checkpoint-data-store.html"/><meta name="DC.relation" content="/external-reference/spl/operator/api/c++/index.html"/><meta name="DC.relation" content="/external-reference/spl/operator/code-generation-api/perl/index.html"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="checkpointing"/><meta name="DC.language" content="en-us"/>        
      <title>Checkpointing</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../../"/><meta name="wh-toc-id" content="checkpointing-d41691e6025"/><meta name="wh-source-relpath" content="com.ibm.streams.dev.doc/doc/checkpointing.dita"/><meta name="wh-out-relpath" content="com.ibm.streams.dev.doc/doc/checkpointing.html"/>

    <link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../../oxygen-webhelp/app/options/properties.js?buildId=20250729150623"></script>
    <script src="../../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../../oxygen-webhelp/app/search/index/keywords.js?buildId=20250729150623"></script>
    <script defer="defer" src="../../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/template/cobalt.css?buildId=2024012323"/><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/template/params/args.css/cobalt.css?buildId=2024012323"/><link rel="stylesheet" type="text/css" href="../../cobalt.css"/></head>

    <body id="checkpointing" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            Jump to main content
        </a>
        
        
        
        
       <!-- <whc:include_html href="${webhelp.fragment.header}"/>-->
        <header class="navbar navbar-default wh_header_tpc" data-whc_version="23.1">
    <div class="container-fluid">
        <div class="wh_header_flex_container_tpc navbar-nav navbar-expand-md navbar-dark"> 
            <!--<div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    <whc:include_html href="${webhelp.fragment.before.logo_and_title}"/>-->
                    <!--
                            This component will be generated when the next parameters are specified in the transformation scenario:
                            'webhelp.logo.image' and 'webhelp.logo.image.target.url'.
                            See: http://oxygenxml.com/doc/versions/17.1/ug-editor/#topics/dita_webhelp_output.html.
                    -->
                    <!--<whc:webhelp_logo class="d-none d-sm-block"/>
                    <whc:webhelp_publication_title/>
                    <whc:include_html href="${webhelp.fragment.after.logo_and_title}"/>
                </div>-->
                
                <!-- The menu button for mobile devices is copied in the output only when the 'webhelp.show.top.menu' parameter is set to 'yes' -->
                
            <!--</div>-->

            <div class="wh_logo_tpc">
                <a href="/index.html"><img width="200px" height="24px" src="/media/home_button.svg" style="margin-top: 1em;"/></a>
        </div>
        <!-- Search form -->
        <div class=" wh_search_input navbar-form wh_main_page_search search " role="form">
            
            
            
            
            
            <!--<div class="wh_welcome">
                <whc:include_html href="${webhelp.fragment.welcome}"/>
            </div>    -->      
            <form id="searchForm" method="get" role="search" action="../../search.html"><div><input type="search" placeholder="Search " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="Search query" required="required"/><button type="submit" class="wh_search_button" aria-label="Search"><span class="search_input_text">Search</span></button></div></form>
            
            
            
            
        </div>
    </div>
</div></header>

        
         
        

        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../../index.html"><span>Home</span></a></span></li><li><div class="topicref" data-id="dev-container"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/dev-container.html">Developing</a><div class="wh-tooltip"><p class="shortdesc">Learn about different Teracloud Streams tools and features to write, compile, run, and    test streams applications.</p></div></div></div></li><li><div class="topicref" data-id="developing_operators"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/developing_operators.html">Developing custom operators</a><div class="wh-tooltip"><p class="shortdesc">Create custom operators if shipped toolkits do not provide the necessary logic or   behavior needed for your <span class="keyword">stream applications</span>.</p></div></div></div></li><li><div class="topicref" data-id="developing_primitive_operators"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/developing_primitive_operators.html">Developing primitive operators</a><div class="wh-tooltip"><p class="shortdesc"> You develop new primitive operators by implementing them in the C++ or Java™ language. You must define an operator model that describes the syntax and semantics of the operator and implement the operator logic by creating the header and implementation code generator templates.</p></div></div></div></li><li><div class="topicref" data-id="creatingprimitiveoperators"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creatingprimitiveoperators.html">Developing C++ primitive operators</a><div class="wh-tooltip"><p class="shortdesc">The SPL language supports writing two styles of primitive operators, namely: generic operators and non-generic operators.</p></div></div></div></li><li><div class="topicref" data-id="advancedoperatorimplementationtopics"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/advancedoperatorimplementationtopics.html">Advanced operator implementation</a><div class="wh-tooltip"><p class="shortdesc">Advanced operator implementation techniques provide additional runtime operator control.</p></div></div></div></li><li class="active"><div class="topicref" data-id="checkpointing"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/checkpointing.html">Checkpointing</a><div class="wh-tooltip"><p class="shortdesc">Checkpointing is the process of persisting operator state at run time to allow recovery         from a failure. In case of failure, the operator can be restarted by resetting from the         checkpointed state. </p></div></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="Toggle search highlights" title="Toggle search highlights"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="Collapse sections" title="Collapse sections"></button>
                        
                        
                        <!-- External resource link -->
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div>
                        
                        <!-- Expand/Collapse publishing TOC 
                             The menu button for mobile devices is copied in the output only when the publication TOC is available
                        -->
                        <button type="button" data-target="#wh_publication_toc" id="wh_toc_button" data-toggle="collapse" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        
                        <nav id="wh_publication_toc" class="collapse col-lg-3 col-md-3 col-sm-12 d-md-block d-print-none" aria-label="Table of Contents Container">
                            <div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem" aria-expanded="false"><div data-tocid="kc_welcome-d41691e179" class="topicref" data-id="kc_welcome" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action kc_welcome-d41691e179-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.welcome.doc/doc/kc-homepage.html" id="kc_welcome-d41691e179-link">Welcome</a><div class="wh-tooltip"><p class="shortdesc">Learn about the core capabilities of <span class="keyword">Teracloud® Streams</span>, its architecture, and key concepts.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="installstreams-container-d41691e427" class="topicref" data-id="installstreams-container" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action installstreams-container-d41691e427-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.install.doc/doc/installstreams-container.html" id="installstreams-container-d41691e427-link">Installing</a><div class="wh-tooltip"><p class="shortdesc"><span class="ph">Use this information to install, upgrade, and uninstall the <span class="keyword">Teracloud® 					Streams</span> product.</span></p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="ibminfospherestreams-containercfg-d41691e1501" class="topicref" data-id="ibminfospherestreams-containercfg" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action ibminfospherestreams-containercfg-d41691e1501-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.cfg.doc/doc/ibminfospherestreams-containercfg.html" id="ibminfospherestreams-containercfg-d41691e1501-link">Configuring</a><div class="wh-tooltip"><p class="shortdesc">Create a basic or an enterprise domain which is a single point for configuring and       managing common resources, security, and instances.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="containeradmin-d41691e2701" class="topicref" data-id="containeradmin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action containeradmin-d41691e2701-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.admin.doc/doc/ibminfospherestreams-containeradmin.html" id="containeradmin-d41691e2701-link">Administering</a><div class="wh-tooltip"><p class="shortdesc">Administer the product by using the <span class="keyword">Teracloud® 					Streams</span> graphical user interface, APIs, or the <code class="ph codeph">streamtool</code> command-line   interface.</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="dev-container-d41691e3979" class="topicref" data-id="dev-container" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action dev-container-d41691e3979-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/dev-container.html" id="dev-container-d41691e3979-link">Developing</a><div class="wh-tooltip"><p class="shortdesc">Learn about different Teracloud Streams tools and features to write, compile, run, and    test streams applications.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="streaming_application_basics-d41691e3994" class="topicref" data-id="streaming_application_basics" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action streaming_application_basics-d41691e3994-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/streaming_application_basics.html" id="streaming_application_basics-d41691e3994-link">Development concepts</a><div class="wh-tooltip"><p class="shortdesc">Development of stream applications consists of several components such as operators,         streams, tuples, Streams Processing Language, toolkits, and         more.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="writingapplications-d41691e4218" class="topicref" data-id="writingapplications" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action writingapplications-d41691e4218-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/writingapplications.html" id="writingapplications-d41691e4218-link">Developing <span class="keyword">stream applications</span></a><div class="wh-tooltip"><p class="shortdesc">Try out tutorials and explore details about stream application development, SPL features,     and best practices.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="creatingnativefunctions-d41691e5698" class="topicref" data-id="creatingnativefunctions" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action creatingnativefunctions-d41691e5698-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creatingnativefunctions.html" id="creatingnativefunctions-d41691e5698-link"><span class="ph">Developing native functions</span></a><div class="wh-tooltip"><p class="shortdesc">Extend SPL's computational capabilities by creating native functions     written in C++ or Java.</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="developing_operators-d41691e5772" class="topicref" data-id="developing_operators" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action developing_operators-d41691e5772-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/developing_operators.html" id="developing_operators-d41691e5772-link">Developing custom operators</a><div class="wh-tooltip"><p class="shortdesc">Create custom operators if shipped toolkits do not provide the necessary logic or   behavior needed for your <span class="keyword">stream applications</span>.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="choosingoperators-d41691e5787" class="topicref" data-id="choosingoperators" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action choosingoperators-d41691e5787-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/str_optype.html" id="choosingoperators-d41691e5787-link">Types of operators</a><div class="wh-tooltip"><p class="shortdesc">  When developing new operators, developers need to choose the kind of operator to implement based on the task they want to accomplish, the programming language they want to use and the trade-offs they are willing to make between generality and ease of implementation.</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="developing_primitive_operators-d41691e5878" class="topicref" data-id="developing_primitive_operators" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action developing_primitive_operators-d41691e5878-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/developing_primitive_operators.html" id="developing_primitive_operators-d41691e5878-link">Developing primitive operators</a><div class="wh-tooltip"><p class="shortdesc"> You develop new primitive operators by implementing them in the C++ or Java™ language. You must define an operator model that describes the syntax and semantics of the operator and implement the operator logic by creating the header and implementation code generator templates.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="true"><div data-tocid="creatingprimitiveoperators-d41691e5892" class="topicref" data-id="creatingprimitiveoperators" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action creatingprimitiveoperators-d41691e5892-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creatingprimitiveoperators.html" id="creatingprimitiveoperators-d41691e5892-link">Developing C++ primitive operators</a><div class="wh-tooltip"><p class="shortdesc">The SPL language supports writing two styles of primitive operators, namely: generic operators and non-generic operators.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="operatorimplementation-d41691e5903" class="topicref" data-id="operatorimplementation" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action operatorimplementation-d41691e5903-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/operatorimplementation.html" id="operatorimplementation-d41691e5903-link">Operator implementation</a><div class="wh-tooltip"><p class="shortdesc">You use skeleton template files that are generated by the <span class="keyword cmdname">spl-make-operator</span> script as the basis for operator implementations.</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="advancedoperatorimplementationtopics-d41691e5953" class="topicref" data-id="advancedoperatorimplementationtopics" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action advancedoperatorimplementationtopics-d41691e5953-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/advancedoperatorimplementationtopics.html" id="advancedoperatorimplementationtopics-d41691e5953-link">Advanced operator implementation</a><div class="wh-tooltip"><p class="shortdesc">Advanced operator implementation techniques provide additional runtime operator control.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="blockingshutdownhandling-d41691e5964" class="topicref" data-id="blockingshutdownhandling" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/blockingshutdownhandling.html" id="blockingshutdownhandling-d41691e5964-link">Blocking and shutdown handling</a><div class="wh-tooltip"><p class="shortdesc">SPL provides functions to block and shut down operator processing elements safely.</p></div></div></div></li><li role="treeitem"><div data-tocid="punctuationprocessing-d41691e5975" class="topicref" data-id="punctuationprocessing" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/punctuationprocessing.html" id="punctuationprocessing-d41691e5975-link">Punctuation processing</a><div class="wh-tooltip"><p class="shortdesc">Punctuation markers in SPL create boundaries. Window punctuation create boundaries within a stream that can be used for creating user-defined windows. Final punctuation is used to mark the end of streams.</p></div></div></div></li><li role="treeitem"><div data-tocid="dynamicstreamimportingexporting-d41691e5986" class="topicref" data-id="dynamicstreamimportingexporting" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/dynamicstreamimportingexporting.html" id="dynamicstreamimportingexporting-d41691e5986-link">Dynamic stream importing and exporting</a><div class="wh-tooltip"><p class="shortdesc">The <span class="keyword apiname">Export</span> operator exports a stream using a set of export properties, which can be modified at run time. Similarly, the <span class="keyword apiname">Import</span> operator is used to import a stream using an import subscription that is defined over the export properties. Import subscriptions can also be changed at run time.</p></div></div></div></li><li role="treeitem"><div data-tocid="logging-d41691e6003" class="topicref" data-id="logging" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/logging.html" id="logging-d41691e6003-link">Logging and tracing</a><div class="wh-tooltip"><p class="shortdesc">When developing C++ primitive operators and native functions, use the    <code class="ph codeph">SPLAPPLOG</code> macro to write messages to the <span class="keyword">Teracloud® 					Streams</span> product log location. Use the <code class="ph codeph">SPLAPPTRC</code> macro to create a trace in the PE   trace files. </p></div></div></div></li><li role="treeitem" class="active"><div data-tocid="checkpointing-d41691e6025" class="topicref" data-id="checkpointing" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/checkpointing.html" id="checkpointing-d41691e6025-link">Checkpointing</a><div class="wh-tooltip"><p class="shortdesc">Checkpointing is the process of persisting operator state at run time to allow recovery         from a failure. In case of failure, the operator can be restarted by resetting from the         checkpointed state. </p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="windowhandling-d41691e6036" class="topicref" data-id="windowhandling" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action windowhandling-d41691e6036-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/windowhandling.html" id="windowhandling-d41691e6036-link">Window handling</a><div class="wh-tooltip"><p class="shortdesc">The SPL language run time provides APIs for building window-based operators. </p></div></div></div></li><li role="treeitem"><div data-tocid="multithreadingandoperatorfusion-d41691e6069" class="topicref" data-id="multithreadingandoperatorfusion" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/multithreadingandoperatorfusion.html" id="multithreadingandoperatorfusion-d41691e6069-link">Multi-threading and operator fusion considerations</a><div class="wh-tooltip"><p class="shortdesc">SPL  operators can potentially run in a multi-threaded context, where the process functions of the operators are invoked concurrently. SPL provides a set of utility classes that  handle threads, locks, and conditional variables to protect against concurrent access.</p></div></div></div></li><li role="treeitem"><div data-tocid="metricaccess-d41691e6080" class="topicref" data-id="metricaccess" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/metricaccess.html" id="metricaccess-d41691e6080-link">Metrics access</a><div class="wh-tooltip"><p class="shortdesc"><dfn class="term">Metrics</dfn> are simple counters that are maintained at run time, which can be read from outside of a running job to monitor statistics. </p></div></div></div></li><li role="treeitem"><div data-tocid="accessingpathsruntime-d41691e6093" class="topicref" data-id="accessingpathsruntime" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/accessingpathsruntime.html" id="accessingpathsruntime-d41691e6093-link">Accessing paths at run time</a><div class="wh-tooltip"><p class="shortdesc">The SPL runtime APIs provide functions to access special paths at run time. These functions are provided as part of the <code class="ph codeph">SPL::ProcessingElement</code> class.</p></div></div></div></li><li role="treeitem"><div data-tocid="usingreflectivetypesystem-d41691e6107" class="topicref" data-id="usingreflectivetypesystem" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/usingreflectivetypesystem.html" id="usingreflectivetypesystem-d41691e6107-link">Using the reﬂective type system</a><div class="wh-tooltip"><p class="shortdesc">The types <code class="ph codeph">ValueHandle</code> and <code class="ph codeph">Meta:BaseType</code> provide support for reflection. The former type is a handle to a value of an SPL type. The latter type is a meta-type that represents an SPL type.</p></div></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="advancedcodegenerationtopics-d41691e6124" class="topicref" data-id="advancedcodegenerationtopics" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action advancedcodegenerationtopics-d41691e6124-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/advancedcodegenerationtopics.html" id="advancedcodegenerationtopics-d41691e6124-link">Advanced code generation</a><div class="wh-tooltip"><p class="shortdesc">When you create generic operators, you can use advanced code generation techniques for more operator customization and control.</p></div></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="javaprimitiveoperators-d41691e6281" class="topicref" data-id="javaprimitiveoperators" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action javaprimitiveoperators-d41691e6281-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/javaprimitiveoperators.html" id="javaprimitiveoperators-d41691e6281-link">Developing Java™ primitive operators</a><div class="wh-tooltip"><p class="shortdesc">To create a Java™ primitive operator inside an SPL toolkit, you must provide an operator model. The process is similar to how you provide operator models for C++ primitive operators.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="dev_python_prim_oper-d41691e6594" class="topicref" data-id="dev_python_prim_oper" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action dev_python_prim_oper-d41691e6594-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/dev-python-prim-oper.html" id="dev_python_prim_oper-d41691e6594-link">Developing Python primitive operators</a><div class="wh-tooltip"><p class="shortdesc">To create a Python primitive operator inside an SPL toolkit, you must provide an         operator model. The process is similar to how you provide operator models for C++ primitive         operators.</p></div></div></div></li></ul></li><li role="treeitem"><div data-tocid="creatingcpluslibraries-d41691e6715" class="topicref" data-id="creatingcpluslibraries" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creatingcpluslibraries.html" id="creatingcpluslibraries-d41691e6715-link">Creating C++ libraries for operators and native functions</a><div class="wh-tooltip"><p class="shortdesc">To enable operators and native functions, you must compile with the appropriate include file paths and options and link any shared libraries against the correct runtime libraries. </p></div></div></div></li><li role="treeitem"><div data-tocid="fusingmultiplejavaoperators-d41691e6726" class="topicref" data-id="fusingmultiplejavaoperators" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/fusingjavaoperators.html" id="fusingmultiplejavaoperators-d41691e6726-link">Fusing multiple Java™ operators into a single PE</a><div class="wh-tooltip"><p class="shortdesc">If multiple Java™ primitive operators and <span class="keyword apiname">JavaOp</span> operator invocations have compatible <span class="keyword parmname">vmArg</span> parameter lists, you can fuse them together into a single processing element (PE) or run them in stand-alone mode.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="best_practices_for_custom_operators-d41691e6749" class="topicref" data-id="best_practices_for_custom_operators" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action best_practices_for_custom_operators-d41691e6749-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/best_practices_for_custom_operators.html" id="best_practices_for_custom_operators-d41691e6749-link">Best practices</a><div class="wh-tooltip"><p class="shortdesc">Use these tips to write operators that perform effectively in their application, and         in other applications.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="perfrecoforprimitiveoperatorimplementors-d41691e6978" class="topicref" data-id="perfrecoforprimitiveoperatorimplementors" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action perfrecoforprimitiveoperatorimplementors-d41691e6978-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/perf_rec_primitive_operatorimplementors.html" id="perfrecoforprimitiveoperatorimplementors-d41691e6978-link">Performance recommendations</a><div class="wh-tooltip"><p class="shortdesc">These tips help you to improve performance of your primitive operators in C++.</p></div></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="creating_toolkits-d41691e7044" class="topicref" data-id="creating_toolkits" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action creating_toolkits-d41691e7044-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creating_toolkits.html" id="creating_toolkits-d41691e7044-link">Developing custom toolkits</a><div class="wh-tooltip"><p class="shortdesc">Bundle and reuse custom functions and operators across several <span class="keyword">stream applications</span> by creating custom toolkits.</p></div></div></div></li><li role="treeitem"><div data-tocid="enabling-streams-application-service-d41691e7457" class="topicref" data-id="enabling-streams-application-service" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/enabling-streams-data-exchange.html" id="enabling-streams-application-service-d41691e7457-link">Enabling Streams data exchange</a><div class="wh-tooltip"><p class="shortdesc"><span class="keyword">Teracloud® 					Streams</span> provides a data exchange REST API for inserting and retrieving tuples within a job to             easily integrate with other data services and external applications. Stream applications             can enable the data exchange feature by using one or more Endpoint             operators.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="spldebugger-container-d41691e7472" class="topicref" data-id="spldebugger-container" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action spldebugger-container-d41691e7472-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/spldebugger-container.html" id="spldebugger-container-d41691e7472-link">Debugging <span class="keyword">stream applications</span></a><div class="wh-tooltip"><p class="shortdesc">Debug stream applications using the interactive, command line-based <span class="keyword">Streams Debugger</span> (<code class="ph codeph">sdb</code>).</p></div></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshootingforproduct-d41691e8087" class="topicref" data-id="troubleshootingforproduct" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshootingforproduct-d41691e8087-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.pd.doc/doc/ts_parent.html" id="troubleshootingforproduct-d41691e8087-link">Troubleshooting</a><div class="wh-tooltip"><p class="shortdesc">Resolve problems with <span class="keyword">Teracloud® Streams</span> using the troubleshooting tools provided with the product as well as the resources             offered by Teracloud Support.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="reference-container-d41691e60879" class="topicref" data-id="reference-container" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action reference-container-d41691e60879-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.ref.doc/doc/reference-container.html" id="reference-container-d41691e60879-link">Reference</a><div class="wh-tooltip"><p class="shortdesc">Find details on the SPL language, toolkits, APIs, commands, and more.</p></div></div></div></li><li role="treeitem"><div data-tocid="glossary-d41691e72254" class="topicref" data-id="glossary" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.glossary.doc/doc/glossary_streams.html" id="glossary-d41691e72254-link">Glossary</a><div class="wh-tooltip"><p class="shortdesc">Use this glossary to find terms and definitions for <span class="keyword">Teracloud® 					Streams</span>.</p></div></div></div></li></ul></div>
                        </nav>
                        
                    
                    
                    <div class="col-lg-9 col-md-9 col-sm-12" id="wh_topic_body">
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1">




<h1 class="- topic/title title topictitle1" id="ariaid-title1">Checkpointing</h1>

<div class="- topic/body body"><p class="- topic/shortdesc shortdesc">Checkpointing is the process of persisting operator state at run time to allow recovery
        from a failure. In case of failure, the operator can be restarted by resetting from the
        checkpointed state. </p>
<div class="- topic/p p">For an operator, checkpointing (and the associated reset) can be triggered in two ways:<ol class="- topic/ol ol">
<li class="- topic/li li">If an operator is within a consistent region, checkpointing/resetting an operator's state is automatically invoked by the consistent region protocol. An operator's state is checkpointed during draining of the consistent region, and reset during resetting of the consistent region. </li>
<li class="- topic/li li">If an operator is outside a consistent region (that is, in an autonomous region), an operator can be configured to perform checkpointing via the <code class="+ topic/ph pr-d/codeph ph codeph">config checkpoint</code> clause in SPL. This type of checkpointing can be further divided into two types: operator driven checkpointing and periodic checkpointing. Operator driven checkpointing is requested explicitly from within the Java/C++ operator code, whereas periodic checkpointing takes place automatically at regular user-defined intervals. In case of failure, the SPL Runtime automatically resets the operator state to the last saved checkpoint. Two sample operators configured with operator driven checkpointing and periodic checkpointing, respectively are given here.</li>
</ol></div>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock scale-80"><code>stream&lt;...&gt; Out1 = MyOper1(...) {
   ...
   config
      checkpoint : operatorDriven; // operator driven checkpointing
      restartable : true;
}
 
stream&lt;...&gt; Out2 = MyOper2(...) {
   ...
   config
      checkpoint : periodic(10.5); // periodic checkpointing; checkpointing interval is 10.5 seconds
      restartable : true;
}
</code></pre></div>
<p class="- topic/p p">In the sample SPL code, operator <code class="+ topic/ph pr-d/codeph ph codeph">MyOper1</code> is configured to perform operator driven checkpointing, and operator <code class="+ topic/ph pr-d/codeph ph codeph">MyOper2</code> is configured to perform periodic checkpointing every 10.5 seconds.</p>
        <p class="- topic/p p">Regardless of the checkpointing type, an operator's checkpoint data is represented as a set of key-value pairs. Each checkpoint has a unique sequence ID as key and the serialized state as value. When checkpointing is invoked, the SPL Runtime automatically assigns a sequence ID, and the operator uses the Checkpointing API to serialize its state data. The resulting checkpoint is stored to some backend persistent data store in the form of key-value pairs. At reset, the SPL Runtime decides which sequence ID to reset from, retrieves the corresponding checkpoint from the backend data store, and resets the operator state by deserializing data from the checkpoint.</p>
<p class="- topic/p p">Since Version 4.0, <span class="- topic/keyword keyword"><span class="- topic/tm tm">Teracloud<span class="- topic/tmmark tmmark ">®</span></span>
					Streams</span> provides a new set of Checkpointing Runtime APIs in both C++ and Java. The new Checkpointing API is part of the C++ and Java Operator Runtime API, and is intended for an operator to checkpoint and reset its state data. It should be noted that the Checkpointing API in versions prior to Version 4.0 is deprecated and we encourage users to use the new API described in this page.</p>
<p class="- topic/p p">The Checkpointing Runtime API has three parts: the <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler</code> interface, the
<code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint</code> class, and the optional <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext</code> class. </p>
<p class="- topic/p p">The first part of the C++ Checkpointing Runtime API is the <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler</code> class. The <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler</code> class defines a set of callback interfaces such as <code class="+ topic/ph pr-d/codeph ph codeph">checkpoint()</code> and <code class="+ topic/ph pr-d/codeph ph codeph">reset()</code> functions. Operator developers provide those callback functions in the operator implementation and register the callback functions with the SPL Runtime. At runtime, the SPL Runtime automatically invokes the registered <code class="+ topic/ph pr-d/codeph ph codeph">checkpoint()</code> and <code class="+ topic/ph pr-d/codeph ph codeph">reset()</code> callback functions to checkpoint and reset an operator's state.</p>
<p class="- topic/p p">An operator class implements the <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler</code> interface by inheriting from it. The following example shows a C++ operator that implements its own <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler</code> callback functions.</p>
<p class="- topic/p p">This code snippet is the header file of the operator implementation:</p>
<div class="- topic/example example">
<pre class="+ topic/pre pr-d/codeblock pre codeblock scale-80"><code>#include &lt;SPL/Runtime/Operator/StateHandler.h&gt;
 
class MY_OPERATOR : public MY_BASE_OPERATOR, StateHandler // inherit from StateHandler
{
public:
    ...
 
    // callback functions from StateHandler.h
    virtual void checkpoint(Checkpoint &amp; ckpt);
    virtual void reset(Checkpoint &amp; ckpt);
    virtual void resetToInitialState();
private:
    // variables myInt_ and myVector_ constitute the state of this operator
    uint32_t myInt_;
    std::vector&lt;IPort0Type&gt; myVector_;    
    Mutex myMutex_; // lock for guarding concurrent access to operator state
};</code></pre>
</div>
<p class="- topic/p p">This code snippet is the C++ file of the operator implementation:</p>
<div class="- topic/example example">
<pre class="+ topic/pre pr-d/codeblock pre codeblock scale-80"><code>// Constructor of operator
MY_OPERATOR::MY_OPERATOR()
    : myInt_(0)
{
    ...
    // register StateHandler callbacks
    getContext().registerStateHandler(*this);
}
 
// process() function for tuple processing
void MY_OPERATOR::process(Tuple const &amp; tuple, uint32_t port)
{
    // acquire lock
    AutoMutex am(myMutex_);
              
    // manipulate operator state during tuple processing
    IPort0Type &amp; ituple = static_cast&lt;IPort0Type &amp;&gt;(tuple);
    myInt_ ++;
    myVector_.push_back(ituple);
 
    // submit tuple downstream
    OPort0Type otuple(tuple.getAttributeValue(0), myInt_);
    submit(otuple, 0);
}
 
// checkpoint() callback to checkpoint operator state data
void MY_OPERATOR::checkpoint(Checkpoint &amp; ckpt)
{
    // acquire lock
    AutoMutex am(myMutex_);
 
    SPLAPPTRC(L_TRACE, "Checkpointing with sequence id: " &lt;&lt; ckpt.getSequenceId(), "MY_OP");
              
    // serialize state data to Checkpoint
    ckpt &lt;&lt; myInt_;
    ckpt &lt;&lt; myVector_; 
}
 
// reset() callback to reset operator state data
void MY_OPERATOR::reset(Checkpoint &amp; ckpt)
{
    // acquire lock
    AutoMutex am(myMutex_);
 
    SPLAPPTRC(L_TRACE, "Resetting with sequence id: " &lt;&lt; ckpt.getSequenceId(), "MY_OP");
              
    // de-serialize state data from Checkpoint   
    ckpt &gt;&gt; myInt_;
    ckpt &gt;&gt; myVector_; 
}
 
// resetToIntialState() callback to reset operator to initial state
void MY_OPERATOR::resetToInitialState()
{
    // acquire lock
    AutoMutex am(myMutex_);
    myInt_ = 0;
    myVector_.clear();
}</code></pre>
</div>
<p class="- topic/p p">For more information on the equivalent Java <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler</code> interface, take a look
            at the SPL Java Operator API documentation.</p>
<p class="- topic/p p">The second part of C++ Checkpointing Runtime API is the <code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint</code> class. The <code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint</code> class provides an abstraction to the checkpoint data. During checkpointing, a <code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint</code> instance is passed to the operator's <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler::checkpoint()</code> callback function. The operator can specify the data to checkpoint by using the <code class="+ topic/ph pr-d/codeph ph codeph">&lt;&lt;</code> operator to serialize data to the provided <code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint</code> instance. The SPL Runtime internally serializes checkpointed data and transfers the data to the backend data store. At reset, a <code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint</code> instance is passed to the operator's <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler::reset()</code> callback function. The operator can extract the data from checkpoint and reset its state by using the <code class="+ topic/ph pr-d/codeph ph codeph">&gt;&gt;</code> operator to deserialize data from the provided <code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint</code> instance.</p>
<p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint</code> class provides serialization and deserialization support for all primitive data types, SPL data types, and typical C++ STL container types. Serialization and deserialization of nested data types are automatically handled as well.</p>
<p class="- topic/p p">Besides serialization and deserialization, operator code can also call the <code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint::getSequenceId()</code> function to get the sequence ID of the checkpoint being written or reset. For an operator within a consistent region, the sequence ID of a checkpoint is the same as the marker ID assigned by the consistent region protocol; for an operator in an autonomous region, the sequence ID is generated by an internal counter local to each operator. In both cases, the sequence ID is a positive integer number and increases with new checkpoints, but the sequence ID numbers are not guaranteed to be consecutive.</p>
<p class="- topic/p p">For more information on the equivalent Java <code class="+ topic/ph pr-d/codeph ph codeph">Checkpoint</code> interface, take a look at
            the SPL Java Operator API documentation.</p>
<p class="- topic/p p">Note that an operator's state has two parts: the optional SPL logic-state variables and the state data. The logic-state variables (if present) are automatically checkpointed and reset by the SPL Runtime, while the state data is checkpointed and reset via operator-provided <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler::checkpoint()</code> and <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler::reset()</code> callbacks.</p>
<p class="- topic/p p">If an operator has logic-state variables, during code generation, the SPL compiler automatically generates two functions to checkpoint and reset the logic-state variables. The signature of the two functions, <code class="+ topic/ph pr-d/codeph ph codeph">checkpointStateVariables()</code> and <code class="+ topic/ph pr-d/codeph ph codeph">resetStateVariables()</code>, are shown here.</p>
<div class="- topic/example example">
<pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// auto-generated functions for checkpointing and resetting logic-state variables
void MY_BASE_OPERATOR::checkpointStateVariables(Checkpoint &amp; ckpt);
void MY_BASE_OPERATOR::resetStateVariables(Checkpoint &amp; ckpt);</code></pre>
</div>
<p class="- topic/p p">During checkpointing, the SPL Runtime first calls the <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler::checkpoint()</code> callback function to checkpoint operator state data, and then automatically calls the <code class="+ topic/ph pr-d/codeph ph codeph">checkpointStateVariables()</code> function to checkpoint logic-state variables. At reset, the SPL Runtime first calls the <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler::reset()</code> callback function to reset operator state data, and then automatically calls the <code class="+ topic/ph pr-d/codeph ph codeph">resetStateVariables()</code> function to reset logic-state variables.</p>
<p class="- topic/p p">The third part of the Checkpointing Runtime API is the optional <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext</code> class. If an operator is in autonomous region, runs in distributed mode, and has <code class="+ topic/ph pr-d/codeph ph codeph">config checkpoint</code> specified to either <code class="+ topic/ph pr-d/codeph ph codeph">operatorDriven</code> or <code class="+ topic/ph pr-d/codeph ph codeph">periodic(T)</code> in SPL, then a <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext</code> instance is provided to the operator. This <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext</code> instance provides functions to query the checkpointing configuration of the operator (such as whether operator driven or periodic checkpointing is configured, and what the periodic checkpointing interval is). This <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext</code> instance also provides a function <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext::createCheckpoint()</code> for operator code to perform operator driven checkpointing. The following code shows how to use the <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext::createCheckpoint()</code> function in operator code for operator driven checkpointing.</p>
<div class="- topic/example example">
<pre class="+ topic/pre pr-d/codeblock pre codeblock scale-70"><code>// the header file which defines CheckpointContext class
#include &lt;SPL/Runtime/Operator/State/CheckpointContext.h&gt;
.... 
// operator code can use CheckpointContext::createCheckpoint() function for operator driven checkpointing;
// to do so, first retrieve the CheckpointContext instance
CheckpointContext * ckptContext = static_cast&lt;CheckpointContext *&gt;(this-&gt;getContext().getOptionalContext(CHECKPOINT));
if (ckptContext != NULL) {
    // then call CheckpointContext::createCheckpoint() to perform checkpointing
    ckptContext-&gt;createCheckpoint();
}</code></pre>
</div>
<p class="- topic/p p">When called from operator code, the <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext::createCheckpoint()</code> function internally invokes the operator's <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler::checkpoint()</code> callback function and the <code class="+ topic/ph pr-d/codeph ph codeph">checkpointStateVariables()</code> function for checkpointing operator's state. The <code class="+ topic/ph pr-d/codeph ph codeph">createCheckpoint()</code> function returns after checkpointing is finished, so checkpointing is synchronous to the calling thread. If checkpointing is successful, the <code class="+ topic/ph pr-d/codeph ph codeph">createCheckpoint()</code> function returns <code class="+ topic/ph pr-d/codeph ph codeph">true</code>. If there is any error during checkpointing, the <code class="+ topic/ph pr-d/codeph ph codeph">createCheckpoint()</code> function throws a <code class="+ topic/ph pr-d/codeph ph codeph">SPL::DataStoreException</code> error. If checkpointing is not performed, the <code class="+ topic/ph pr-d/codeph ph codeph">createCheckpoint()</code> function does nothing and returns <code class="+ topic/ph pr-d/codeph ph codeph">false</code>. Starting with Version 4.0, the <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext::createCheckpoint()</code> function either returns <code class="+ topic/ph pr-d/codeph ph codeph">true</code> or throws exception; the case of returning <code class="+ topic/ph pr-d/codeph ph codeph">false</code> is reserved.</p>
<p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext</code> instance is not available to an operator which either runs in standalone mode or does not have <code class="+ topic/ph pr-d/codeph ph codeph">config checkpoint</code> specified in SPL. In those cases, the <code class="+ topic/ph pr-d/codeph ph codeph">OperatorContext::getOptionalContext(CHECKPOINT)</code> function returns <code class="+ topic/ph pr-d/codeph ph codeph">NULL</code>. </p>
<p class="- topic/p p">For more information on the equivalent Java <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext</code> interface, take a
            look at the SPL Java Operator API documentation. </p>
<div class="- topic/p p">To use the Checkpointing API, follow these guidelines: <ol class="- topic/ol ol">
<li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">Locking in the Checkpointing API:</strong><p class="- topic/p p">For consistent region driven checkpointing and periodic checkpointing, the <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler::checkpoint()</code> callback function is called by an internal SPL Runtime thread, and is asynchronous to tuple processing or the background operator thread. Therefore, SPL Runtime requires operator code to manage user-defined locks to ensure that the checkpointing thread has exclusive access to the operator state. For operator driven checkpointing, the thread that calls the <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext::createCheckpoint()</code> function internally executes the <code class="+ topic/ph pr-d/codeph ph codeph">StateHandler::checkpoint()</code> callback function. If the <code class="+ topic/ph pr-d/codeph ph codeph">checkpoint()</code> callback function tries to acquire any lock that is already held by the calling thread, the calling thread can block itself, resulting in a deadlock. SPL Runtime requires operator code to manage user-defined locks to ensure that the thread that checkpoints the operator state does not create a deadlock by acquiring the same user-defined locks more than once. One recommended solution to avoid this deadlock issue is to use some form of re-entrant lock, such as <code class="+ topic/ph pr-d/codeph ph codeph">boost::recursive_mutex</code>.</p></li>
<li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">Example usage of the Checkpointing API:</strong><div class="- topic/p p">Although there are several different types of checkpointing, with proper use of the Checkpointing API, it is easy to implement an operator that can be used in different scenarios and perform checkpointing and resetting properly. The following example shows an operator that can be used in these scenarios:<ul class="- topic/ul ul">
<li class="- topic/li li">It can be used within a consistent region and perform consistent region driven checkpointing and resetting.</li>
<li class="- topic/li li">It can be used outside consistent regions, run in distributed mode, and perform periodic checkpointing when <code class="+ topic/ph pr-d/codeph ph codeph">config checkpoint</code> is set to <code class="+ topic/ph pr-d/codeph ph codeph">periodic(T)</code> in SPL;</li>
<li class="- topic/li li">It can be used outside consistent regions, run in distributed mode, and perform operator driven checkpointing when <code class="+ topic/ph pr-d/codeph ph codeph">config checkpoint</code> is set to <code class="+ topic/ph pr-d/codeph ph codeph">operatorDriven</code> in SPL;</li>
<li class="- topic/li li">It can be used outside consistent regions, run in distributed mode, and do not perform any checkpointing or resetting when <code class="+ topic/ph pr-d/codeph ph codeph">config checkpoint</code> is not set in SPL;</li>
<li class="- topic/li li">It can run in standalone mode, and do not perform any checkpointing or resetting.</li>
</ul></div></li>
</ol></div>
<p class="- topic/p p">This code snippet is the <code class="+ topic/ph pr-d/codeph ph codeph">MyOp_h.cgt</code> file of the operator implementation:</p>
<div class="- topic/example example">
<pre class="+ topic/pre pr-d/codeblock pre codeblock scale-70"><code>&lt;%
    # use CodeGen API to query whether the operator is used inside a consistent region
    my $isInConsistentRegion = $model-&gt;getContext()-&gt;getOptionalContext("ConsistentRegion");
    # if operator is outside consistent region, use CodeGen API to determine the kind of checkpointing (none, periodic, or operatorDriven)
    my $ckptKind = $model-&gt;getContext()-&gt;getCheckpointingKind();
    my @includes;
    if ($isInConsistentRegion) {
        push @includes, "#include &lt;SPL/Runtime/Operator/State/StateHandler.h&gt;";
    }
    if ($ckptKind ne "none") {
        push @includes, "#include &lt;SPL/Runtime/Operator/State/CheckpointContext.h&gt;";
    }
    SPL::CodeGen::headerPrologue($model, \@includes);   
%&gt;

&lt;% if ($ckptKind eq "operatorDirven") { %&gt;
#include &lt;boost/thread/recursive_mutex.hpp&gt;
&lt;% } %&gt;
 
class MY_OPERATOR : public MY_BASE_OPERATOR
&lt;% if ($isInConsistentRegion || $ckptKind ne "none") {%&gt;
, public StateHandler
&lt;% } %&gt; {
public:
    // constructor
    MY_OPERATOR();
              
    // destructor
    virtual ~MY_OPERATOR();
   
    // tuple processing for mutating ports
    void process(Tuple &amp; tuple, uint32_t port);
    ...
 
&lt;% if ($isInConsistentRegion || $ckptKind ne "none") { %&gt;
    // StateHandler callbacks
    virtual void checkpoint(Checkpoint &amp; ckpt);
    virtual void reset(Checkpoint &amp; ckpt);
    virtual void resetToIntialState();
&lt;% } %&gt;
 
private:
&lt;% if ($ckptKind eq "operatorDirven") { %&gt;
    // for operator-driven checkpointing, use a re-entrant lock to guard operator state
    // so that the thread calling createCheckpoint() does not deadlock itself
    boost::recursive_mutex myLock_; 
&lt;% } else { %&gt;
    // for all other cases, use SPL::Mutex
    Mutex myLock_;
&lt;% } %&gt;
    // variables myVar1_ and myVar2_ constitute this operator's state
    int myVar1_;
    float myVar2_;
};</code></pre>
</div>
<p class="- topic/p p">This code snippet is the <code class="+ topic/ph pr-d/codeph ph codeph">MyOp_cpp.cgt</code> file of the operator implementation:</p>
<div class="- topic/example example">
<pre class="+ topic/pre pr-d/codeblock pre codeblock scale-70"><code>&lt;%
   # use CodeGen API to query whether the operator is used inside a consistent region
   my $isInConsistentRegion = $model-&gt;getContext()-&gt;getOptionalContext("ConsistentRegion");
   # if operator is outside consistent region, use CodeGen API to determine the kind of checkpointing (none, periodic, or operatorDriven)
   my $ckptKind = $model-&gt;getContext()-&gt;getCheckpointingKind();
%&gt;
...
 
&lt;%if ($isInConsistentRegion || $ckptKind ne "none") {%&gt;
 
// operator-provided StateHandler::checkpoint() callback
void MY_OPERATOR::checkpoint(Checkpoint &amp; ckpt)
{
    &lt;% if ($ckptKind eq " operatorDirven ") {
        // this operator is used outside consistent region and is configured with operator driven checkpointing
        // in this case, myLock_ is an re-entrant lock
        boost::recursive_mutex::scoped_lock am(myLock_);
    &lt;% } else { %&gt;
        // this operator is in consistent region, or outside consistent region but configured with periodic checkpointing
        // in this case, myLock_ is a regular SPL::Mutex
        AutoMutex am(myLock_);
    &lt;% } %&gt;
    // checkpoint operator state
    ckpt &lt;&lt; myVar1_ &lt;&lt; myVar2_;
}
 
// operator-provided StateHandler::reset() callback
void MY_OPERATOR::reset(Checkpoint &amp; ckpt)
{
    &lt;% if ($ckptKind eq " operatorDirven ") {
        // this operator is used outside consistent region and is configured with operator driven checkpointing
        // in this case, myLock_ is an re-entrant lock
        boost::recursive_mutex::scoped_lock am(myLock_);
    &lt;% } else { %&gt;
        // this operator is in consistent region, or outside consistent region but configured with periodic checkpointing
        // in this case, myLock_ is a regular SPL::Mutex
        AutoMutex am(myLock_);
    &lt;% } %&gt;
    // reset operator state
    ckpt &gt;&gt; myVar1_ &gt;&gt; myVar2_;
}
 
// operator-provided StateHandler::resetToInitialState() callback
void MY_OPERATOR::resetToInitialState()
{
    &lt;% if ($ckptKind eq " operatorDirven ") {
        // this operator is used outside consistent region and is configured with operator driven checkpointing
        // in this case, myLock_ is an re-entrant lock
        boost::recursive_mutex::scoped_lock am(myLock_);
    &lt;% } else { %&gt;
        // this operator is in consistent region, or outside consistent region but configured with periodic checkpointing
        // in this case, myLock_ is a regular SPL::Mutex
        AutoMutex am(myLock_);
    &lt;% } %&gt;
    // reset operator state to initial values
    myVar1_ = 0;
    myVar2_ = 0.0;
}
&lt;%}%&gt;
 
// tuple processing function
void MY_OPERATOR::process(Tuple &amp; tuple, uint32_t port)
{
    &lt;% if ($ckptKind eq " operatorDirven ") {
        // this operator is used outside consistent region and is configured with operator driven checkpointing
        // in this case, myLock_ is an re-entrant lock
        boost::recursive_mutex::scoped_lock am(myLock_);
    &lt;% } else { %&gt;
        // this operator is in consistent region, or outside consistent region but configured with periodic checkpointing
        // in this case, myLock_ is a regular SPL::Mutex
        AutoMutex am(myLock_);
    &lt;% } %&gt;
    // process tuple and manipulate operator state
    IPort0Type &amp; ituple = static_cast&lt;IPort0Type &amp;&gt;(tuple);
    myVar1_ += ituple.get_myInt();
    myVar2_ += ituple.get_myFloat();
 
    // perform operator driven checkpointing synchronously
    CheckpointContext * ckptContext = static_cast&lt;CheckpointContext *&gt;(this-&gt;getContext().getOptionalContext(CHECKPOINT));
    if (ckptContext != NULL &amp;&amp; ckptContext-&gt;getKind() == CheckpointContext::operatorDriven) {
        ckptContext-&gt;createCheckpoint();
    }
}</code></pre>
</div>
<p class="- topic/p p">In the example code, the operator differentiates whether it is configured to do <code class="+ topic/ph pr-d/codeph ph codeph">operatorDriven</code> checkpointing or other kinds of checkpointing (periodic or consistent-cut driven). If it's <code class="+ topic/ph pr-d/codeph ph codeph">operatorDriven</code> checkpointing, the operator code uses a re-entrant lock to guard operator state, so that when the <code class="+ topic/ph pr-d/codeph ph codeph">CheckpointContext::createCheckpoint()</code> function is called from the <code class="+ topic/ph pr-d/codeph ph codeph">process()</code> function, the <code class="+ topic/ph pr-d/codeph ph codeph">checkpoint()</code> callback function does not cause a deadlock on the calling thread by trying to acquire the same lock already held by the thread. For other kinds of checkpointing, the operator code uses a regular <code class="+ topic/ph pr-d/codeph ph codeph">SPL::Mutex</code> lock. </p>
<p class="- topic/p p">If the operator does not use operator driven checkpointing in its code, there is no need to use a re-entrant lock to avoid deadlock. In that case, the operator code can just use a regular <code class="+ topic/ph pr-d/codeph ph codeph">SPL::Mutex</code> lock, and checking the type of checkpointing at code-generation time can be removed.</p>
</div>

</article></main></div>
                        
                        
                        <div class=" wh_related_links d-print-none "><nav aria-label="Related Links" role="navigation" class="- topic/related-links related-links"><div class="- topic/linklist linklist relconcepts" xml:lang="en-us" lang="en-us"><strong>Related concepts</strong><ul class="linklist related_link"><li class="linklist"><a class="- topic/link link navheader_parent_path" href="../../com.ibm.streams.dev.doc/doc/consistentregions.html" title="Because of business requirements, some applications require that all tuples in an application are processed at least once. You can use a consistent region in your stream applications to avoid data loss due to software or hardware failure and meet your requirements for at-least-once processing.">Developing stream applications with consistent regions</a></li></ul></div><div class="- topic/linklist linklist reltasks" xml:lang="en-us" lang="en-us"><strong>Related tasks</strong><ul class="linklist related_link"><li class="linklist"><a class="- topic/link link navheader_parent_path" href="../../com.ibm.streams.cfg.doc/doc/ibminfospherestreams-configuring-checkpoint-data-store.html" title="See more information about configuring the checkpoint data store.">Configuring the checkpoint data store</a></li></ul></div><div class="- topic/linklist linklist relinfo" xml:lang="en-us" lang="en-us"><strong>Related information</strong><ul class="linklist related_link"><li class="linklist"><a class="- topic/link link navheader_parent_path" href="../../com.ibm.streams.dev.doc/doc/implementingoperators.html" title="An operator is implemented as a C++ class that extends from the SPL runtime class SPL::Operator.">Implementing operators</a></li><li class="linklist"><a class="- topic/link link navheader_parent_path" href="/external-reference/spl/operator/api/c++/index.html" target="_blank" rel="external noopener" title="SPL Operator Runtime C++ API Documentation">SPL Operator Runtime C++ API Documentation</a></li><li class="linklist"><a class="- topic/link link navheader_parent_path" href="/external-reference/spl/operator/code-generation-api/perl/index.html" target="_blank" rel="external noopener" title="SPL Operator Runtime Java API Documentation">SPL Operator Runtime Java API Documentation</a></li></ul></div></nav></div>
                        
                        <whc:webhelp_feedback xmlns="" xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="d-print-none"></whc:webhelp_feedback>
                        
                        
                    </div>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer" data-whc_version="23.1"> 

  <!--<whc:include_html href="${webhelp.fragment.footer}"/>-->
  
  <div class="footer-container">
    
    <div class="grid-container">
        
        
        <div class="hf"><h4 class="head">Teracloud Streams</h4>
          
          <p class="text-gray">Revolutionizing real-time data analytics with advanced tools, AI integration, and unparalleled expertise.</p></div>
        
        <div class="hs"><h4 class="head">Quick Links</h4>
          <a href="https://streams.teracloud.com" target="_blank" rel="noopener noreferrer" class="links blue">Official Website</a><br/>
            <a href="https://teracloud.com" target="_blank" rel="noopener noreferrer" class="links blue">About Teracloud</a><br/>
            <a href="https://teracloud.com/privacy" target="_blank" rel="noopener noreferrer" class="links blue">Privacy Policy</a>
          </div>
        
        <div class="ht"><h4 class="head">Contact Us</h4>
          
          <a href="mailto:info.streams@teracloud.com" class="text-gray2 links">info.streams@teracloud.com</a></div>
        
        
      
      <div class="bottom-row">© 2025 Teracloud. All rights reserved.</div></div>
  </div>

</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <!-- The modal container for images -->
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <!-- Modal Content (The Image) -->
            <img class="modal-content" id="modal-img" alt=""/>
            <!-- Modal Caption (Image Text) -->
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>