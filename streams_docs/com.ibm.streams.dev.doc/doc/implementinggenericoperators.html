<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" data-whc_version="22.0">
    <head><link rel="shortcut icon" href="../../favicon-light.png"/><link rel="icon" href="../../favicon-light.png"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="DC.rights.owner" content="(C) Copyright 2025"/><meta name="copyright" content="(C) Copyright 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="description" content="Generic operators are implemented through code generation."/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/operatorimplementation.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/dev-container.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/developing_operators.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/developing_primitive_operators.html"/><meta name="DC.relation" content="../../com.ibm.streams.dev.doc/doc/creatingprimitiveoperators.html"/><meta name="DC.relation" content="/external-reference/spl/operator/code-generation-api/perl/index.html"/><meta name="DC.relation" content="../../com.ibm.streams.ref.doc/doc/streamoperinstancenames.html"/><meta name="DC.relation" content="../../com.ibm.streams.ref.doc/doc/operatormodel.html"/><meta name="DC.relation" content="/external-reference/spl/operator/api/c++/index.html"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="implementinggenericoperators"/><meta name="DC.language" content="en-us"/>        
      <title>Implementing generic operators</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../../"/><meta name="wh-toc-id" content="implementinggenericoperators-d41691e5942"/><meta name="wh-source-relpath" content="com.ibm.streams.dev.doc/doc/implementinggenericoperators.dita"/><meta name="wh-out-relpath" content="com.ibm.streams.dev.doc/doc/implementinggenericoperators.html"/>

    <link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../../oxygen-webhelp/app/options/properties.js?buildId=20250729150623"></script>
    <script src="../../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../../oxygen-webhelp/app/search/index/keywords.js?buildId=20250729150623"></script>
    <script defer="defer" src="../../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/template/cobalt.css?buildId=2024012323"/><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/template/params/args.css/cobalt.css?buildId=2024012323"/><link rel="stylesheet" type="text/css" href="../../cobalt.css"/></head>

    <body id="implementinggenericoperators" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            Jump to main content
        </a>
        
        
        
        
       <!-- <whc:include_html href="${webhelp.fragment.header}"/>-->
        <header class="navbar navbar-default wh_header_tpc" data-whc_version="23.1">
    <div class="container-fluid">
        <div class="wh_header_flex_container_tpc navbar-nav navbar-expand-md navbar-dark"> 
            <!--<div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    <whc:include_html href="${webhelp.fragment.before.logo_and_title}"/>-->
                    <!--
                            This component will be generated when the next parameters are specified in the transformation scenario:
                            'webhelp.logo.image' and 'webhelp.logo.image.target.url'.
                            See: http://oxygenxml.com/doc/versions/17.1/ug-editor/#topics/dita_webhelp_output.html.
                    -->
                    <!--<whc:webhelp_logo class="d-none d-sm-block"/>
                    <whc:webhelp_publication_title/>
                    <whc:include_html href="${webhelp.fragment.after.logo_and_title}"/>
                </div>-->
                
                <!-- The menu button for mobile devices is copied in the output only when the 'webhelp.show.top.menu' parameter is set to 'yes' -->
                
            <!--</div>-->

            <div class="wh_logo_tpc">
                <a href="/index.html"><img width="200px" height="24px" src="/media/home_button.svg" style="margin-top: 1em;"/></a>
        </div>
        <!-- Search form -->
        <div class=" wh_search_input navbar-form wh_main_page_search search " role="form">
            
            
            
            
            
            <!--<div class="wh_welcome">
                <whc:include_html href="${webhelp.fragment.welcome}"/>
            </div>    -->      
            <form id="searchForm" method="get" role="search" action="../../search.html"><div><input type="search" placeholder="Search " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="Search query" required="required"/><button type="submit" class="wh_search_button" aria-label="Search"><span class="search_input_text">Search</span></button></div></form>
            
            
            
            
        </div>
    </div>
</div></header>

        
         
        

        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../../index.html"><span>Home</span></a></span></li><li><div class="topicref" data-id="dev-container"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/dev-container.html">Developing</a><div class="wh-tooltip"><p class="shortdesc">Learn about different Teracloud Streams tools and features to write, compile, run, and    test streams applications.</p></div></div></div></li><li><div class="topicref" data-id="developing_operators"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/developing_operators.html">Developing custom operators</a><div class="wh-tooltip"><p class="shortdesc">Create custom operators if shipped toolkits do not provide the necessary logic or   behavior needed for your <span class="keyword">stream applications</span>.</p></div></div></div></li><li><div class="topicref" data-id="developing_primitive_operators"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/developing_primitive_operators.html">Developing primitive operators</a><div class="wh-tooltip"><p class="shortdesc"> You develop new primitive operators by implementing them in the C++ or Java™ language. You must define an operator model that describes the syntax and semantics of the operator and implement the operator logic by creating the header and implementation code generator templates.</p></div></div></div></li><li><div class="topicref" data-id="creatingprimitiveoperators"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creatingprimitiveoperators.html">Developing C++ primitive operators</a><div class="wh-tooltip"><p class="shortdesc">The SPL language supports writing two styles of primitive operators, namely: generic operators and non-generic operators.</p></div></div></div></li><li><div class="topicref" data-id="operatorimplementation"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/operatorimplementation.html">Operator implementation</a><div class="wh-tooltip"><p class="shortdesc">You use skeleton template files that are generated by the <span class="keyword cmdname">spl-make-operator</span> script as the basis for operator implementations.</p></div></div></div></li><li class="active"><div class="topicref" data-id="implementinggenericoperators"><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/implementinggenericoperators.html">Implementing generic operators</a><div class="wh-tooltip"><p class="shortdesc">Generic operators are implemented through code generation. </p></div></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="Toggle search highlights" title="Toggle search highlights"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="Collapse sections" title="Collapse sections"></button>
                        
                        
                        <!-- External resource link -->
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div>
                        
                        <!-- Expand/Collapse publishing TOC 
                             The menu button for mobile devices is copied in the output only when the publication TOC is available
                        -->
                        <button type="button" data-target="#wh_publication_toc" id="wh_toc_button" data-toggle="collapse" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        
                        <nav id="wh_publication_toc" class="collapse col-lg-3 col-md-3 col-sm-12 d-md-block d-print-none" aria-label="Table of Contents Container">
                            <div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem" aria-expanded="false"><div data-tocid="kc_welcome-d41691e179" class="topicref" data-id="kc_welcome" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action kc_welcome-d41691e179-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.welcome.doc/doc/kc-homepage.html" id="kc_welcome-d41691e179-link">Welcome</a><div class="wh-tooltip"><p class="shortdesc">Learn about the core capabilities of <span class="keyword">Teracloud® Streams</span>, its architecture, and key concepts.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="installstreams-container-d41691e427" class="topicref" data-id="installstreams-container" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action installstreams-container-d41691e427-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.install.doc/doc/installstreams-container.html" id="installstreams-container-d41691e427-link">Installing</a><div class="wh-tooltip"><p class="shortdesc"><span class="ph">Use this information to install, upgrade, and uninstall the <span class="keyword">Teracloud® 					Streams</span> product.</span></p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="ibminfospherestreams-containercfg-d41691e1501" class="topicref" data-id="ibminfospherestreams-containercfg" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action ibminfospherestreams-containercfg-d41691e1501-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.cfg.doc/doc/ibminfospherestreams-containercfg.html" id="ibminfospherestreams-containercfg-d41691e1501-link">Configuring</a><div class="wh-tooltip"><p class="shortdesc">Create a basic or an enterprise domain which is a single point for configuring and       managing common resources, security, and instances.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="containeradmin-d41691e2701" class="topicref" data-id="containeradmin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action containeradmin-d41691e2701-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.admin.doc/doc/ibminfospherestreams-containeradmin.html" id="containeradmin-d41691e2701-link">Administering</a><div class="wh-tooltip"><p class="shortdesc">Administer the product by using the <span class="keyword">Teracloud® 					Streams</span> graphical user interface, APIs, or the <code class="ph codeph">streamtool</code> command-line   interface.</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="dev-container-d41691e3979" class="topicref" data-id="dev-container" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action dev-container-d41691e3979-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/dev-container.html" id="dev-container-d41691e3979-link">Developing</a><div class="wh-tooltip"><p class="shortdesc">Learn about different Teracloud Streams tools and features to write, compile, run, and    test streams applications.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="streaming_application_basics-d41691e3994" class="topicref" data-id="streaming_application_basics" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action streaming_application_basics-d41691e3994-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/streaming_application_basics.html" id="streaming_application_basics-d41691e3994-link">Development concepts</a><div class="wh-tooltip"><p class="shortdesc">Development of stream applications consists of several components such as operators,         streams, tuples, Streams Processing Language, toolkits, and         more.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="writingapplications-d41691e4218" class="topicref" data-id="writingapplications" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action writingapplications-d41691e4218-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/writingapplications.html" id="writingapplications-d41691e4218-link">Developing <span class="keyword">stream applications</span></a><div class="wh-tooltip"><p class="shortdesc">Try out tutorials and explore details about stream application development, SPL features,     and best practices.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="creatingnativefunctions-d41691e5698" class="topicref" data-id="creatingnativefunctions" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action creatingnativefunctions-d41691e5698-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creatingnativefunctions.html" id="creatingnativefunctions-d41691e5698-link"><span class="ph">Developing native functions</span></a><div class="wh-tooltip"><p class="shortdesc">Extend SPL's computational capabilities by creating native functions     written in C++ or Java.</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="developing_operators-d41691e5772" class="topicref" data-id="developing_operators" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action developing_operators-d41691e5772-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/developing_operators.html" id="developing_operators-d41691e5772-link">Developing custom operators</a><div class="wh-tooltip"><p class="shortdesc">Create custom operators if shipped toolkits do not provide the necessary logic or   behavior needed for your <span class="keyword">stream applications</span>.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="choosingoperators-d41691e5787" class="topicref" data-id="choosingoperators" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action choosingoperators-d41691e5787-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/str_optype.html" id="choosingoperators-d41691e5787-link">Types of operators</a><div class="wh-tooltip"><p class="shortdesc">  When developing new operators, developers need to choose the kind of operator to implement based on the task they want to accomplish, the programming language they want to use and the trade-offs they are willing to make between generality and ease of implementation.</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="developing_primitive_operators-d41691e5878" class="topicref" data-id="developing_primitive_operators" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action developing_primitive_operators-d41691e5878-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/developing_primitive_operators.html" id="developing_primitive_operators-d41691e5878-link">Developing primitive operators</a><div class="wh-tooltip"><p class="shortdesc"> You develop new primitive operators by implementing them in the C++ or Java™ language. You must define an operator model that describes the syntax and semantics of the operator and implement the operator logic by creating the header and implementation code generator templates.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="true"><div data-tocid="creatingprimitiveoperators-d41691e5892" class="topicref" data-id="creatingprimitiveoperators" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action creatingprimitiveoperators-d41691e5892-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creatingprimitiveoperators.html" id="creatingprimitiveoperators-d41691e5892-link">Developing C++ primitive operators</a><div class="wh-tooltip"><p class="shortdesc">The SPL language supports writing two styles of primitive operators, namely: generic operators and non-generic operators.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="true"><div data-tocid="operatorimplementation-d41691e5903" class="topicref" data-id="operatorimplementation" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action operatorimplementation-d41691e5903-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/operatorimplementation.html" id="operatorimplementation-d41691e5903-link">Operator implementation</a><div class="wh-tooltip"><p class="shortdesc">You use skeleton template files that are generated by the <span class="keyword cmdname">spl-make-operator</span> script as the basis for operator implementations.</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="cplustypes-d41691e5917" class="topicref" data-id="cplustypes" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/cplustypes.html" id="cplustypes-d41691e5917-link">C++ types</a><div class="wh-tooltip"><p class="shortdesc">C++ types in SPL are typically implemented based on the  C++ standard library or other well established libraries.</p></div></div></div></li><li role="treeitem"><div data-tocid="implementingoperators-d41691e5928" class="topicref" data-id="implementingoperators" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/implementingoperators.html" id="implementingoperators-d41691e5928-link">Implementing operators</a><div class="wh-tooltip"><p class="shortdesc">An operator is implemented as a C++ class that extends from the SPL runtime class <code class="ph codeph">SPL::Operator</code>.</p></div></div></div></li><li role="treeitem" class="active"><div data-tocid="implementinggenericoperators-d41691e5942" class="topicref" data-id="implementinggenericoperators" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/implementinggenericoperators.html" id="implementinggenericoperators-d41691e5942-link">Implementing generic operators</a><div class="wh-tooltip"><p class="shortdesc">Generic operators are implemented through code generation. </p></div></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="advancedoperatorimplementationtopics-d41691e5953" class="topicref" data-id="advancedoperatorimplementationtopics" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action advancedoperatorimplementationtopics-d41691e5953-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/advancedoperatorimplementationtopics.html" id="advancedoperatorimplementationtopics-d41691e5953-link">Advanced operator implementation</a><div class="wh-tooltip"><p class="shortdesc">Advanced operator implementation techniques provide additional runtime operator control.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="advancedcodegenerationtopics-d41691e6124" class="topicref" data-id="advancedcodegenerationtopics" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action advancedcodegenerationtopics-d41691e6124-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/advancedcodegenerationtopics.html" id="advancedcodegenerationtopics-d41691e6124-link">Advanced code generation</a><div class="wh-tooltip"><p class="shortdesc">When you create generic operators, you can use advanced code generation techniques for more operator customization and control.</p></div></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="javaprimitiveoperators-d41691e6281" class="topicref" data-id="javaprimitiveoperators" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action javaprimitiveoperators-d41691e6281-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/javaprimitiveoperators.html" id="javaprimitiveoperators-d41691e6281-link">Developing Java™ primitive operators</a><div class="wh-tooltip"><p class="shortdesc">To create a Java™ primitive operator inside an SPL toolkit, you must provide an operator model. The process is similar to how you provide operator models for C++ primitive operators.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="dev_python_prim_oper-d41691e6594" class="topicref" data-id="dev_python_prim_oper" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action dev_python_prim_oper-d41691e6594-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/dev-python-prim-oper.html" id="dev_python_prim_oper-d41691e6594-link">Developing Python primitive operators</a><div class="wh-tooltip"><p class="shortdesc">To create a Python primitive operator inside an SPL toolkit, you must provide an         operator model. The process is similar to how you provide operator models for C++ primitive         operators.</p></div></div></div></li></ul></li><li role="treeitem"><div data-tocid="creatingcpluslibraries-d41691e6715" class="topicref" data-id="creatingcpluslibraries" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creatingcpluslibraries.html" id="creatingcpluslibraries-d41691e6715-link">Creating C++ libraries for operators and native functions</a><div class="wh-tooltip"><p class="shortdesc">To enable operators and native functions, you must compile with the appropriate include file paths and options and link any shared libraries against the correct runtime libraries. </p></div></div></div></li><li role="treeitem"><div data-tocid="fusingmultiplejavaoperators-d41691e6726" class="topicref" data-id="fusingmultiplejavaoperators" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/fusingjavaoperators.html" id="fusingmultiplejavaoperators-d41691e6726-link">Fusing multiple Java™ operators into a single PE</a><div class="wh-tooltip"><p class="shortdesc">If multiple Java™ primitive operators and <span class="keyword apiname">JavaOp</span> operator invocations have compatible <span class="keyword parmname">vmArg</span> parameter lists, you can fuse them together into a single processing element (PE) or run them in stand-alone mode.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="best_practices_for_custom_operators-d41691e6749" class="topicref" data-id="best_practices_for_custom_operators" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action best_practices_for_custom_operators-d41691e6749-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/best_practices_for_custom_operators.html" id="best_practices_for_custom_operators-d41691e6749-link">Best practices</a><div class="wh-tooltip"><p class="shortdesc">Use these tips to write operators that perform effectively in their application, and         in other applications.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="perfrecoforprimitiveoperatorimplementors-d41691e6978" class="topicref" data-id="perfrecoforprimitiveoperatorimplementors" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action perfrecoforprimitiveoperatorimplementors-d41691e6978-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/perf_rec_primitive_operatorimplementors.html" id="perfrecoforprimitiveoperatorimplementors-d41691e6978-link">Performance recommendations</a><div class="wh-tooltip"><p class="shortdesc">These tips help you to improve performance of your primitive operators in C++.</p></div></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="creating_toolkits-d41691e7044" class="topicref" data-id="creating_toolkits" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action creating_toolkits-d41691e7044-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/creating_toolkits.html" id="creating_toolkits-d41691e7044-link">Developing custom toolkits</a><div class="wh-tooltip"><p class="shortdesc">Bundle and reuse custom functions and operators across several <span class="keyword">stream applications</span> by creating custom toolkits.</p></div></div></div></li><li role="treeitem"><div data-tocid="enabling-streams-application-service-d41691e7457" class="topicref" data-id="enabling-streams-application-service" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/enabling-streams-data-exchange.html" id="enabling-streams-application-service-d41691e7457-link">Enabling Streams data exchange</a><div class="wh-tooltip"><p class="shortdesc"><span class="keyword">Teracloud® 					Streams</span> provides a data exchange REST API for inserting and retrieving tuples within a job to             easily integrate with other data services and external applications. Stream applications             can enable the data exchange feature by using one or more Endpoint             operators.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="spldebugger-container-d41691e7472" class="topicref" data-id="spldebugger-container" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action spldebugger-container-d41691e7472-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.dev.doc/doc/spldebugger-container.html" id="spldebugger-container-d41691e7472-link">Debugging <span class="keyword">stream applications</span></a><div class="wh-tooltip"><p class="shortdesc">Debug stream applications using the interactive, command line-based <span class="keyword">Streams Debugger</span> (<code class="ph codeph">sdb</code>).</p></div></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshootingforproduct-d41691e8087" class="topicref" data-id="troubleshootingforproduct" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshootingforproduct-d41691e8087-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.pd.doc/doc/ts_parent.html" id="troubleshootingforproduct-d41691e8087-link">Troubleshooting</a><div class="wh-tooltip"><p class="shortdesc">Resolve problems with <span class="keyword">Teracloud® Streams</span> using the troubleshooting tools provided with the product as well as the resources             offered by Teracloud Support.</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="reference-container-d41691e60879" class="topicref" data-id="reference-container" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action reference-container-d41691e60879-link" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.ref.doc/doc/reference-container.html" id="reference-container-d41691e60879-link">Reference</a><div class="wh-tooltip"><p class="shortdesc">Find details on the SPL language, toolkits, APIs, commands, and more.</p></div></div></div></li><li role="treeitem"><div data-tocid="glossary-d41691e72254" class="topicref" data-id="glossary" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../../com.ibm.streams.glossary.doc/doc/glossary_streams.html" id="glossary-d41691e72254-link">Glossary</a><div class="wh-tooltip"><p class="shortdesc">Use this glossary to find terms and definitions for <span class="keyword">Teracloud® 					Streams</span>.</p></div></div></div></li></ul></div>
                        </nav>
                        
                    
                    
                    <div class="col-lg-9 col-md-9 col-sm-12" id="wh_topic_body">
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1">
<h1 class="- topic/title title topictitle1" id="ariaid-title1">Implementing generic operators</h1>

<div class="- topic/body body"><p class="- topic/shortdesc shortdesc">Generic operators are implemented through code generation. </p>
<p class="- topic/p p">The code generation logic
sits within segments that are marked by <code class="+ topic/ph pr-d/codeph ph codeph">&lt;%</code> and <code class="+ topic/ph pr-d/codeph ph codeph">%&gt;</code> and
is used to generate C++ code to augment the C++ code that sits outside
the sections. The generator code is written with the Perl language.
Here is a simple example.</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>cerr &lt;&lt; "&lt;% print 'Hello World'; %&gt;" &lt;&lt; endl;
</code></pre></div>
<p class="- topic/p p">This mixed-mode code simply translates into C++ code that prints
a message. While this example is illustrative in terms of the code
generation mechanics, it does not represent a common use case. During
development of generic primitive operators, the need for code generation
arises because the code needs to be customized based on the configuration
of the operator instance at hand. The specific instance configuration
is accessible to the code generator through a <var class="+ topic/keyword sw-d/varname keyword varname">$model</var> variable.
As a result, in most cases, the generator code involves variables
that depend on the <var class="+ topic/keyword sw-d/varname keyword varname">$model</var>. For instance:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&lt;% my $kind = $model-&gt;getContext()-&gt;getKind(); %&gt;
...  
cerr &lt;&lt; "The operator is of kind &lt;%=$kind%&gt;" &lt;&lt; endl;
</code></pre></div>
<p class="- topic/p p">The code generation segments can be used throughout the code. Furthermore, variables
that are defined in one segment are available in later segments as
they are visible in the current Perl lexical scope. This example also shows
a shorthand notation for printing variables. The following two forms
are equivalent: <span class="+ topic/ph pr-d/synph ph synph"><code class="+ topic/ph pr-d/codeph ph codeph">&lt;% print $var; %&gt;</code></span> and <span class="+ topic/ph pr-d/synph ph synph"><code class="+ topic/ph pr-d/codeph ph codeph">&lt;%=
$var %&gt;</code></span>.</p>
<p class="- topic/p p">The model object represents an operator instance configuration,
which is based on how the operator instance is configured in the SPL
code. Some of the fundamental pieces of information available in the
model include, but are not limited to:</p>
<ul class="- topic/ul ul">
<li class="- topic/li li">Windowing configuration, such as window type, eviction policy,
trigger policy,</li>
<li class="- topic/li li">Parameter configuration, such as parameter names, types, values.</li>
<li class="- topic/li li">Input and output port information, such as number of ports, port
tuple types.</li>
<li class="- topic/li li">Output attribute assignments, such as assignment expressions,
output functions.</li>
</ul>
<div class="- topic/p p">The model object, represented by the variable <var class="+ topic/keyword sw-d/varname keyword varname">$model</var> in
the generator code, is of type <code class="+ topic/ph pr-d/codeph ph codeph">SPL::Operator::Instance::OperatorInstance</code>. You
can find API documentation on Perl classes and modules in the <span class="+ topic/ph sw-d/filepath ph filepath">$STREAMS_INSTALL/doc/spl/operator/code-generation-api/perl</span> directory
after you install <span class="- topic/keyword keyword"><span class="- topic/tm tm">Teracloud<span class="- topic/tmmark tmmark ">®</span></span>
					Streams</span>. In
addition to the classes that represent the operator instance model
and various objects that are contained within it, SPL also provides
a module that is called <code class="+ topic/ph pr-d/codeph ph codeph">SPL::CodeGen.pm</code>, which provides
helper routines for common code generation tasks.</div>
<div class="- topic/p p">The generated operator code for an operator instance can be found
under the application directory, at <span class="+ topic/ph sw-d/filepath ph filepath">output/src/operator</span>. The
code generation takes place when an application that uses the operator
is built. For an operator instance named <code class="+ topic/ph pr-d/codeph ph codeph">A.B.C</code>, the
code for it is generated into files <span class="+ topic/ph sw-d/filepath ph filepath">C.h</span> and <span class="+ topic/ph sw-d/filepath ph filepath">C.cpp</span> under
the directory <span class="+ topic/ph sw-d/filepath ph filepath">output/src/operator/A/B</span>. Consider the following example:</div>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>composite MyOp (input In; output Out) {
  ...  
  stream&lt;Out&gt; Out = Filter(In) {...}
}
...
stream&lt;MyType&gt; A = MyOp(B) {...}

</code></pre></div>
<p class="- topic/p p">The instance of the <span class="+ topic/keyword pr-d/apiname keyword apiname">Filter</span> operator that appears
is named as <code class="+ topic/ph pr-d/codeph ph codeph">A.Out</code> and the code for it can be found
under the directory <span class="+ topic/ph sw-d/filepath ph filepath">output/src/operator/A</span> in
files <span class="+ topic/ph sw-d/filepath ph filepath">Out.h</span> and <span class="+ topic/ph sw-d/filepath ph filepath">Out.cpp</span>.</p>
<section class="- topic/section section"><h2 class="- topic/title title sectiontitle">Parameter Handling</h2></section>
<div class="- topic/p p"> There are three different forms of parameters, depending on the
kind of expression that is allowed as values. The types are attribute-free
expressions, custom literals, and expressions that reference input
tuple attributes. As an example
of an attribute-free parameter, consider the <code class="+ topic/ph pr-d/codeph ph codeph">size</code> parameter:</div>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>stream&lt;MyType&gt; Out = MyOper(In) {
  param
    size : pow(2,10) - pow(10,2);
  ...  
}
</code></pre></div>
<p class="- topic/p p">To customize the generated code that is based on the value of the <code class="+ topic/ph pr-d/codeph ph codeph">size</code> parameter,
the code generation support might be used as follows:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&lt;%
  my $sizeParam = $model-&gt;getParameterByName("size");
  my $size = (not $sizeParam) ? "10" :
    $sizeParam-&gt;getValueAt(0)-&gt;getCppExpression();
%&gt;
...
int32 size = &lt;%=$size%&gt;;
</code></pre></div>
<p class="- topic/p p">The generated code is equivalent to <code class="+ topic/ph pr-d/codeph ph codeph">int32 size = pow(2,10)
- pow(10,2);</code>. However, the operator model allows the compiler
to rewrite expressions, the generated code looks like <code class="+ topic/ph pr-d/codeph ph codeph">int32
size = lit$0;</code><a name="fnsrc_1" href="#fntarg_1" class=" topic/fn-call fn-call "><sup>1</sup></a>. This method saves the
compiler from generating repeated code for operator instances that
differ only slightly in their parameter configurations, such as <code class="+ topic/ph pr-d/codeph ph codeph">size:
10;</code> versus <code class="+ topic/ph pr-d/codeph ph codeph">size: pow(2, 3);</code>.</p>
<p class="- topic/p p">As an example of a custom literal parameter, consider the <code class="+ topic/ph pr-d/codeph ph codeph">format</code> parameter.</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>stream&lt;MyType&gt; Out = MyOper(In) {
  param
    format: txt;
  ...
}
</code></pre></div>
<p class="- topic/p p">In this example, <code class="+ topic/ph pr-d/codeph ph codeph">txt</code> is a custom literal that
is defined in the operator model. The value of this parameter can
be inspected at code generation time to generate different, specialized
code. For instance:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&lt;%
  my $formatParam = $model-&gt;getParameterByName("format");
  my $format = (not $formatParam) ? "csv" :
    $formatParam-&gt;getValueAt(0)-&gt;getSPLExpression();
%&gt;
...
&lt;%if ($format eq "csv") {%&gt;
  ... // C++ code for csv
&lt;%} elsif ($format eq "txt") {%&gt;
  ... // C++ code for txt
&lt;%}%&gt;
</code></pre></div>
<p class="- topic/p p">In the code <code class="+ topic/ph pr-d/codeph ph codeph">$format</code> does not contain an expression
that might be embedded into the generated code, instead it contains
a value that is to be inspected by the generator code, to emit customized
C++ code.</p>
<p class="- topic/p p">Inspecting the SPL expression that is returned by <code class="+ topic/ph pr-d/codeph ph codeph">getSPLExpression()</code> should only
be done if <code class="+ topic/ph pr-d/codeph ph codeph">rewriteAllowed</code> is <code class="+ topic/ph pr-d/codeph ph codeph">false</code>,
or the parameter has expression type <code class="+ topic/ph pr-d/codeph ph codeph">Constant</code>.  If <code class="+ topic/ph pr-d/codeph ph codeph">rewriteAllowed</code> is <code class="+ topic/ph pr-d/codeph ph codeph">true</code>,
the SPL compiler can create only one version of the operator, using
a runtime value to instantiate several versions. If it is done, then
the value that is returned by <code class="+ topic/ph pr-d/codeph ph codeph">getSPLExpression()</code> corresponds
to only one of the instantiated operators. When <code class="+ topic/ph pr-d/codeph ph codeph">rewriteAllowed</code> is
true, <code class="+ topic/ph pr-d/codeph ph codeph">getSPLExpression()</code> should only be used for
reporting errors at compile time, and not used to generate code.</p>
<p class="- topic/p p">As an example of a free-form expression that can reference input
tuple attributes, consider the filter parameter.</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>stream&lt;uint64 id, uint32 cnt&gt; In = ...
stream&lt;MyType&gt; Out = MyOper(In) {
  param
    filter: id !=0 &amp;&amp; cnt &lt; 40;
  ...
}
</code></pre></div>
<p class="- topic/p p">In this example, the <span class="+ topic/keyword pr-d/parmname keyword parmname">filter</span> parameter is configured
with the expression <code class="+ topic/ph pr-d/codeph ph codeph">id !=0 &amp;&amp; cnt &lt; 40</code>.
The expression references tuple attributes from the input stream and
must be evaluated each time that a new tuple is received. The code
generator template for this operator can employ code like the following
to achieve this result:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&lt;%
  my $filterParam = $model-&gt;getParameterByName("filter");
  my $filter = (not $filterParam) ? "true" :
    $filterParam-&gt;getValueAt(0)-&gt;getCppExpression();
  my $iport = $model-&gt;getInputPortAt(0);
  my $ituple = $iport-&gt;getCppTupleName();
%&gt;
void MY_OPERATOR::process(Tuple &amp; tuple, uint32_t port) {
  assert(port==0); // this op should have a single port
  IPort0Type &amp; &lt;%=$ituple%&gt; = static_cast&lt;IPort0Type &amp;&gt;(tuple);
  if (&lt;%=$filter%&gt;) {
    ...
  }
  ...
}
</code></pre></div>
<p class="- topic/p p">The key point in this example is to make sure that the expression
contained in <code class="+ topic/ph pr-d/codeph ph codeph">$filter</code> is valid when it gets emitted
as C++ code. For that purpose, a tuple with the right type and the
right variable name in scope is needed. As shown by the following
line of code in this example:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>IPort0Type &amp; &lt;%=$ituple%&gt; = static_cast&lt;IPort0Type &amp;&gt;(tuple);
</code></pre></div>
<p class="- topic/p p">The statement performs two important functions. First, it casts
the generic <code class="+ topic/ph pr-d/codeph ph codeph">Tuple</code> to its actual type of <code class="+ topic/ph pr-d/codeph ph codeph">IPort0Type</code> (also
available as <code class="+ topic/ph pr-d/codeph ph codeph">&lt;%=$iport-&gt;getCppTupleType()%&gt;</code>).
Second, it creates an alias that is named <code class="+ topic/ph pr-d/codeph ph codeph">$ituple</code>,
which is the same name that is used in the <code class="+ topic/ph pr-d/codeph ph codeph">$filter</code> expression
to refer to the input tuple. In effect, it creates a reference variable
with the right name and type, so that the <code class="+ topic/ph pr-d/codeph ph codeph">$filter</code> expression
is valid.</p>
<p class="- topic/p p">An alternative, hygienic way of creating a C++ expression that
references input tuples, and is valid within the current context, is
to use the <code class="+ topic/ph pr-d/codeph ph codeph">adaptCppExpression</code> method that is provided
by the <code class="+ topic/ph pr-d/codeph ph codeph">SPL::CodeGen</code> module, which takes, as parameters,
the C++ expression, and the names of the tuple variables that are
in the current scope. It is illustrated as follows:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&lt;% # assume that the 'filter' parameter is mandatory
  my $filterParam = $model-&gt;getParameterByName("filter");
  my $filterExpr = $filterParam-&gt;getValueAt(0)-&gt;getCppExpression();
%&gt;
void MY_OPERATOR::process(Tuple &amp; tuple, uint32_t port) {
  if (&lt;%=SPL::CodeGen:adaptCppExpression($filterExpr, "tuple")%&gt;) {
    ...
  }
}
</code></pre></div>
<p class="- topic/p p">In the example, the local variable name <code class="+ topic/ph pr-d/codeph ph codeph">tuple</code> is
passed to the <code class="+ topic/ph pr-d/codeph ph codeph">adaptCppExpression</code> method, so that
the tuple references in the C++ expression are tied to the local variable <code class="+ topic/ph pr-d/codeph ph codeph">tuple</code>. If
there can be more than one port that is referenced in an expression,
then a list of tuple variable names can be passed to the <code class="+ topic/ph pr-d/codeph ph codeph">adaptCppExpression</code> method,
one for each input port, in order and with no gaps.</p>
<p class="- topic/p p">Often a default value or expression is used in a code generation
template when a parameter is not specified in the operator instance model. This
can be achieved by introducing a simple Perl function that checks
for the existence of the parameter and returns the right context-dependent
expression. This technique is illustrated in the following example:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>
&lt;%
  sub getFilterExpr {
    my $filterParam = $model-&gt;getParameterByName("filter");
    return "true" unless($filterParam); # the default value is 'true'
    my $expr = $filterParam-&gt;getValueAt(0)-&gt;getCppExpression();
    return SPL::CodeGen:adaptCppExpression($expr, @_);
  }
%&gt;
void MY_OPERATOR::process(Tuple &amp; tuple, uint32_t port) {
  if (&lt;%=getFilterExpr("tuple")%&gt;) {
    ...
  }
}
</code></pre></div>
<div class="- topic/p p">Parameters with expressions that do not involve stream
tuples or attributes, and whose values are only known at run time, are
available at run time in a form that is based on the <code class="+ topic/ph pr-d/codeph ph codeph">getParameter_name()</code> functions
for non-generic operators. The <code class="+ topic/ph pr-d/codeph ph codeph">SPL::Operator</code> class
contains typedefs and functions to access parameter values at run time:<ul class="- topic/ul ul">
<li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">const std::tr1::unordered_set&lt;std::string&gt;&amp; getParameterNames()
const</code> returns a set of strings that contain the names of
all parameters.</li>
<li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">const ParameterValueListType&amp; getParameterValues(std::string
const &amp; param) const</code> returns expression value of type <code class="+ topic/ph pr-d/codeph ph codeph">ParameterValue</code> that
can be inspected at run time to extract type information and the value
of the expression. The values might have different types if no type
was specified for the parameter in the operator model.</li>
<li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">const  std::tr1::unordered_map&lt;std::string, std::vector&lt;ConstValueHandle&gt;*
&gt;&amp; getParameters()</code> returns the map from parameter name
to a pointer to a list of <code class="+ topic/ph pr-d/codeph ph codeph">ConstValueHandle</code>.</li>
</ul>These interfaces are
also available for non-generic operators.</div>
<section class="- topic/section section"><h2 class="- topic/title title sectiontitle">Output Assignment Handling</h2></section>
<p class="- topic/p p"> There are two forms of output assignments, plain assignments and
assignments with output functions.</p>
<p class="- topic/p p">The assignment for the output stream that is named <code class="+ topic/ph pr-d/codeph ph codeph">Out</code> in
the following SPL segment is an example of plain output assignment.</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>stream&lt;uint64 id&gt; In = ...
stream&lt;rstring name, uint64 id&gt; Out = MyOper(In) {
  ...
  output
    Out: id = hashCode(id), name = (rstring)id + "_id";
}
</code></pre></div>
<p class="- topic/p p">The output assignment can be implemented as follows in the code
generator:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&lt;%
  my $iport = $model-&gt;getInputPortAt(0);
  my $ituple = $iport-&gt;getCppTupleName();
  my $oport = $model-&gt;getOutputPortAt(0);
  # Get the output tuple constructor initializer based on the output
  # attribute assignments that appear in the operator instance model
  my $otupleInit = SPL::CodeGen::getOutputTupleCppInitializer($oport);
%&gt;
...
void MY_OPERATOR::process(Tuple &amp; tuple, uint32_t port)
{
  IPort0Type &amp; &lt;%=$ituple%&gt; = static_cast&lt;IPort0Type &amp;&gt;(tuple);
  ...
  OPort0Type otuple(&lt;%=$otupleInit%&gt;);
  submit(otuple, 0);
}
</code></pre></div>
<p class="- topic/p p">In this example, the <code class="+ topic/ph pr-d/codeph ph codeph">SPL::CodeGen::getOutputTupleCppInitializer</code> helper
routine creates a tuple initializer when given the output port object.
This routine simply uses all of the output assignment expressions
to create a tuple initializer. This initializer is later used to create
an output tuple of the right type and initialize it with the expressions
that appear in the attribute assignment expressions for the output port.
The generated code is as follows (some namespace qualifiers are omitted
for clarity):</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>OPort0Type otuple(hashCode(tuple$0.get_id()),
                  spl_cast&lt;rstring&gt;(tuple$0.get_id())+rstring("_id"));
</code></pre></div>
<p class="- topic/p p">An alternate helper routine is <code class="+ topic/ph pr-d/codeph ph codeph">SPL::CodeGen::emitSubmitOutputTuple</code>,
which can forward a tuple directly from an input port to an output
port, if the input and output port schemas are identical, the port mutabilities
are compatible, and the output attribute assignments indicate that
the tuple is simply being forwarded from the input port to the output port.
If not, <code class="+ topic/ph pr-d/codeph ph codeph">SPL::CodeGen::getOutputTupleCppInitializer</code> is
used to generate the output tuple. An example use from the <span class="+ topic/keyword pr-d/apiname keyword apiname">Functor</span> operator
follows:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>void MY_OPERATOR::process(Tuple const &amp; tuple, uint32_t port) {
  IPort0Type const &amp; &lt;%=$ituple%&gt; = static_cast&lt;IPort0Type const&amp;&gt;(tuple);
  if (&lt;%=$filterExpr%&gt;) {
    &lt;%SPL::CodeGen::emitSubmitOutputTuple($oport, $iport);%&gt;
  }
}</code></pre></div>
<p class="- topic/p p">While not a recommended practice, this result might also be achieved
without employing the <code class="+ topic/ph pr-d/codeph ph codeph">SPL::CodeGen</code> module, but by
manually traversing the output assignments, as follows:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&lt;%
  foreach my $attribute (@{$oport-&gt;getAttributes()}) {          
    my $name = $attribute-&gt;getName();
    my $value = $attribute-&gt;getAssignmentValue();
    my $valueExpr = $value-&gt;getCppExpression();
    ...
  }
%&gt;
</code></pre></div>
<p class="- topic/p p">Look at an output assignment with output functions, that is, output
attribute assignments that involve custom output functions. The assignment
for the output stream that is named <code class="+ topic/ph pr-d/codeph ph codeph">Out</code> is an example
in the following SPL code segment:</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>stream&lt;rstring name, uint64 salary&gt; In = ...
stream&lt;In&gt; Out = Aggregate(In) {
  window
    In : tumbling, count(10);
  output
    Out : salary = Max(salary),
         name = ArgMax(salary, name);
}
</code></pre></div>
<p class="- topic/p p">The following code segment illustrates how the output port object
of the operator instance model can be used to retrieve the output
function (such as <code class="+ topic/ph pr-d/codeph ph codeph">ArgMax</code>) and the assignment value
expressions (<code class="+ topic/ph pr-d/codeph ph codeph">ituple$0.get_salary()</code> and <code class="+ topic/ph pr-d/codeph ph codeph">ituple$0.get_name()</code>)
 for each output attribute.</p>
<div class="- topic/example example"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&lt;%
  foreach my $attribute (@{$oport-&gt;getAttributes()}) {
    my $name = $attribute-&gt;getName();
    my $aggregate = $attribute-&gt;getAssignmentOutputFunctionName();
    my $paramValues = $attribute-&gt;getAssignmentOutputFunctionParameterValues();
    foreach my $value (@{$paramValues}) {
      my $valueExpr = $value-&gt;getCppExpression();
      ...
    }
  }
%&gt;
</code></pre></div>
<p class="- topic/p p">The following code segment verifies whether the attribute
has an assignment that uses a custom output function and shows how
to extract the arguments to the custom output function.</p>
<div class="- topic/example example">

<pre class="+ topic/pre pr-d/codeblock pre codeblock scale-80"><code>&lt;%
  foreach my $attribute (@{$oport-&gt;getAttributes()}) {
    my $name = $attribute-&gt;getName();
    # Does this attribute have an assignment using a custom output function?
    if ($attribute-&gt;hasAssignmentWithOutputFunction()) {
      # Which custom output is being referenced?
      my $fcn = $attribute-&gt;getAssignmentOutputFunctionName();
      # extract the arguments to the custom output function
      if ($fcn eq "Max") {
        # implementation of the Max function - extract the first (and only) argument
        my $maxArg = $attribute-&gt;getAssignmentOutputFunctionParameterValueAt(0);
        # Access the argument as a C++ expression
        my $maxValue = $maxArg-&gt;getCppExpression();
        # Use the argument in some manner, such as: %&gt;
        ... // C++ code here using &lt;%=$maxValue%&gt;
      &lt;%} elsif ($fcn eq "ArgMax") {
        # implementation of the ArgMax function - extract the two arguments
        my $maxArg = $attribute-&gt;getAssignmentOutputFunctionParameterValueAt(0);
        my $argArg = $attribute-&gt;getAssignmentOutputFunctionParameterValueAt(1);
        # Access the arguments as a C++ expression
        my $maxValue = $maxArg-&gt;getCppExpression();
        my $argValue = $argArg-&gt;getCppExpression();
        # We may need to know the C++ type of max to declare a temporary variable
        my $maxCppType = $maxArg-&gt;getCppType();
        # Use the arguments in some manner, such as:
        ... // C++ code here using &lt;%=$maxValue%&gt;, &lt;%=$argValue%&gt; and possibly &lt;%=$maxCppType%&gt;
      &lt;%}
    } elsif ($attribute-&gt;getAssignmentValue()) {
        # An output expression that doesn't use a Custom Output Expression
        # Example code, assuming otuple is already declared:
        my $assign = $attribute-&gt;getAssignmentValue()-&gt;getCppExpression();%&gt;
        otuple.set_&lt;%=$name%&gt;(&lt;%=$assign%&gt;);
    &lt;%} else {
          # This attribute was not mentioned on the output clause
          # Should we take some default action for this attribute?
    }
  }
%&gt;</code></pre>
</div>
</div>

<div class="- topic/fn fn"><a name="fntarg_1" href="#fnsrc_1"><sup>1</sup></a>  The value of <code class="+ topic/ph pr-d/codeph ph codeph">lit$0</code> is computed
at compile-time and loaded at run time.</div></article></main></div>
                        
                        
                        <div class=" wh_related_links d-print-none "><nav aria-label="Related Links" role="navigation" class="- topic/related-links related-links"><div class="- topic/linklist linklist relref" xml:lang="en-us" lang="en-us"><strong>Related reference</strong><ul class="linklist related_link"><li class="linklist"><a class="- topic/link link navheader_parent_path" href="/external-reference/spl/operator/code-generation-api/perl/index.html" target="_blank" rel="external noopener" title="This is the SPL Operator Code Generation API documentation. This API is used to develop generic SPL primitive operators using code generator templates (.cgt files), in order to achieve a level of reusability and genericity that is not available to SPL primitive operators written in pure C++ or Java.">SPL Operator Code Generation API Documentation</a></li><li class="linklist"><a class="- topic/link link navheader_parent_path" href="../../com.ibm.streams.ref.doc/doc/streamoperinstancenames.html" title="SPL has rules for giving names to operators, operator instances, streams, and ports.">Stream and operator instance names</a></li><li class="linklist"><a class="- topic/link link navheader_parent_path" href="../../com.ibm.streams.ref.doc/doc/operatormodel.html" title="An operator model is an XML document that describes the basic properties of a primitive operator. Primitive operator developers are tasked with providing operator models that describe the basic syntactic and semantic properties of the new operators that they want to add to the SPL language. Here, we will list the major properties that can be specified using the operator model.">C++ Operator Model</a></li><li class="linklist"><a class="- topic/link link navheader_parent_path" href="/external-reference/spl/operator/api/c++/index.html" target="_blank" rel="external noopener" title="This is the SPL Runtime C++ API documentation. These APIs are used to develop SPL primitive operators in C++ and native functions in C++.">SPL Operator Runtime C++ API Documentation </a></li></ul></div></nav></div>
                        
                        <whc:webhelp_feedback xmlns="" xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="d-print-none"></whc:webhelp_feedback>
                        
                        
                    </div>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer" data-whc_version="23.1"> 

  <!--<whc:include_html href="${webhelp.fragment.footer}"/>-->
  
  <div class="footer-container">
    
    <div class="grid-container">
        
        
        <div class="hf"><h4 class="head">Teracloud Streams</h4>
          
          <p class="text-gray">Revolutionizing real-time data analytics with advanced tools, AI integration, and unparalleled expertise.</p></div>
        
        <div class="hs"><h4 class="head">Quick Links</h4>
          <a href="https://streams.teracloud.com" target="_blank" rel="noopener noreferrer" class="links blue">Official Website</a><br/>
            <a href="https://teracloud.com" target="_blank" rel="noopener noreferrer" class="links blue">About Teracloud</a><br/>
            <a href="https://teracloud.com/privacy" target="_blank" rel="noopener noreferrer" class="links blue">Privacy Policy</a>
          </div>
        
        <div class="ht"><h4 class="head">Contact Us</h4>
          
          <a href="mailto:info.streams@teracloud.com" class="text-gray2 links">info.streams@teracloud.com</a></div>
        
        
      
      <div class="bottom-row">© 2025 Teracloud. All rights reserved.</div></div>
  </div>

</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <!-- The modal container for images -->
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <!-- Modal Content (The Image) -->
            <img class="modal-content" id="modal-img" alt=""/>
            <!-- Modal Caption (Image Text) -->
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>