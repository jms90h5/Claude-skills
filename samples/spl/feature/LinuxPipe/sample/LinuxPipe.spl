// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// THIS SAMPLE CODE IS PROVIDED ON AN "AS IS" BASIS.                
// TERACLOUD APS AND IBM MAKES NO REPRESENTATIONS OR WARRANTIES,    
// EXPRESS OR IMPLIED, CONCERNING  USE OF THE SAMPLE CODE, OR THE   
// COMPLETENESS OR ACCURACY OF THE SAMPLE CODE. TERACLOUD APS       
// AND IBM DOES NOT WARRANT UNINTERRUPTED OR ERROR-FREE OPERATION   
// OF THIS SAMPLE CODE. TERACLOUD APS AND IBM IS NOT RESPONSIBLE FOR THE 
// RESULTS OBTAINED FROM THE USE OF THE SAMPLE CODE OR ANY PORTION  
// OF THIS SAMPLE CODE.                                             
//                                                                  
// LIMITATION OF LIABILITY. IN NO EVENT WILL IBM BE LIABLE TO ANY   
// PARTY FOR ANY DIRECT, INDIRECT, SPECIAL OR OTHER CONSEQUENTIAL   
// DAMAGES FOR ANY USE OF THIS SAMPLE CODE, THE USE OF CODE FROM    
// THIS [ SAMPLE PACKAGE,] INCLUDING, WITHOUT LIMITATION, ANY LOST  
// PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA   
// ON YOUR INFORMATION HANDLING SYSTEM OR OTHERWISE.                
//                                                                  
// (C) Copyright Teracloud ApS 2024, 2025, IBM Corp. 2010, 2013     
// All Rights reserved.                                             
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 

/** 
This sample program illustrates how to run Linux pipe commands in an SPL application. 

As part of this, it uses a primitive operator that implements the basic functionality 
of running a Linux pipe command and retrieving the results (standard output and error 
to two different streams).
*/
                               
namespace sample;

composite Main
{
  graph
    // An spl.adapter::FileSource operator reads some sample text from a file and sends it as a stream of rstring tuples, one tuple
    // for each line in the input file.
    stream<rstring ln> Src = FileSource() { 
      param file: "in.txt"; 
            format: line;
    }
    
    // A sample::LinuxPipe operator that takes the output of the FileSource and processes it through a sequence of two sed commands.
    // The stdout stream from the second sed command is sent on the operator's output port; the stderr stream is discarded.
    stream<rstring ln> OutA = LinuxPipe(Src) { 
      param command: "sed 's/Streams/Teracloud Streams/g' | sed 's/Spade/SPL/g'"; 
    }

    // Another sample::LinuxPipe operator that takes the output of the first LinuxPipe instance and processes it through a sequence
    // of a sed command piped into a grep command.
    // The stdout stream from the grep command is sent on the operator's first output port; the stderr stream is sent on the 
    // second output port.
    (stream<rstring ln> OutB; stream<rstring ln> ErrB) = LinuxPipe(OutA) { 
      param command: "sed 's/teracloud/Teracloud/g' | grep -v '^[ ]*#'";
    }

    // An spl.adapter::FileSink operator that writes the stdout output of the first LinuxPipe operator instance to the file outA.txt.
    () as WriterA = FileSink(OutA) {
      param file: "outA.txt";
            quoteStrings : false;
    }

    // An spl.adapter::FileSink operator that writes the stdout output of the second LinuxPipe operator instance to the file outB.txt.
    () as WriterB = FileSink(OutB) {
      param file: "outB.txt";
            quoteStrings : false;
    }

    // An spl.adapter::FileSink operator that writes the stderr output of the second LinuxPipe operator instance to the file errB.txt.
    () as WriterC = FileSink(ErrB) {
      param file: "errB.txt";
            format: line;
    }
} 
