// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// THIS SAMPLE CODE IS PROVIDED ON AN "AS IS" BASIS.                
// TERACLOUD APS AND IBM MAKES NO REPRESENTATIONS OR WARRANTIES,    
// EXPRESS OR IMPLIED, CONCERNING  USE OF THE SAMPLE CODE, OR THE   
// COMPLETENESS OR ACCURACY OF THE SAMPLE CODE. TERACLOUD APS       
// AND IBM DOES NOT WARRANT UNINTERRUPTED OR ERROR-FREE OPERATION   
// OF THIS SAMPLE CODE. TERACLOUD APS AND IBM IS NOT RESPONSIBLE FOR THE     
// RESULTS OBTAINED FROM THE USE OF THE SAMPLE CODE OR ANY PORTION   
// OF THIS SAMPLE CODE.                                              
//                                                                   
// LIMITATION OF LIABILITY. IN NO EVENT WILL IBM BE LIABLE TO ANY    
// PARTY FOR ANY DIRECT, INDIRECT, SPECIAL OR OTHER CONSEQUENTIAL    
// DAMAGES FOR ANY USE OF THIS SAMPLE CODE, THE USE OF CODE FROM     
// THIS [ SAMPLE PACKAGE,] INCLUDING, WITHOUT LIMITATION, ANY LOST   
// PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA    
// ON YOUR INFORMATION HANDLING SYSTEM OR OTHERWISE.                 
//                                                                   
// (C) Copyright Teracloud ApS 2024, 2024, IBM Corp. 2009, 2012     
// All Rights reserved.                                             
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 

#pragma SPL_NON_GENERIC_OPERATOR_IMPLEMENTATION_PROLOGUE

MY_OPERATOR::MY_OPERATOR()
    : windowOfReadings_(*this /*oper*/, 0 /*port*/, 
                        CountWindowPolicy(getParameter_size()), // eviction 
                        CountWindowPolicy(1)) // trigger                       
{
    windowOfReadings_.registerBeforeTupleEvictionHandler(this);
}
 
MY_OPERATOR::~MY_OPERATOR()
{
    windowOfReadings_.deleteWindowObjects();
} 

void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
    AutoPortMutex apm(mutex_, *this);
    if(port==0) {
        IPort0Type const & reading = static_cast<IPort0Type const&>(tuple);
        windowOfReadings_.insert(new IPort0Type(reading));
    } else {
        IPort1Type const & query = static_cast<IPort1Type const&>(tuple);
        IPort1Type::position_type const & qPos = query.get_position();
        WindowType::DataType & content = windowOfReadings_.getWindowData();
        for(WindowType::DataType::iterator it=content.begin(); it!=content.end(); ++it) {
            IPort0Type const & reading = **it;
            IPort0Type::position_type const & rPos = reading.get_position();
            float64 distance = SPL::Functions::Math::sqrt(
                                   SPL::Functions::Math::pow(rPos.get_x()-qPos.get_x(), 2.0) +
                                   SPL::Functions::Math::pow(rPos.get_y()-qPos.get_y(), 2.0));
            if(distance<=query.get_distance()) {
                OPort0Type otuple(query.get_queryId(), reading.get_sensorId(), reading.get_value());
                submit(otuple, 0);
                uintptr_t ptr = reinterpret_cast<uintptr_t>(&reading);
                map<uintptr_t,uint32>::iterator mit = matchedReadings_.find(ptr);
                if(mit==matchedReadings_.end())
                    matchedReadings_.insert(std::make_pair(ptr,1));
                else
                    mit->second = mit->second+1;
            }              
        }
    }
}

void MY_OPERATOR::beforeTupleEvictionEvent(Window<IPort0Type*> & window, 
                                           IPort0Type * & reading, int const &)
{
    uintptr_t ptr = reinterpret_cast<uintptr_t>(reading);
    map<uintptr_t,uint32>::iterator mit = matchedReadings_.find(ptr);
    if(mit!=matchedReadings_.end()) {        
        uint32 numMatches = mit->second;
        if(numMatches >= getParameter_threshold())
            submit(*reading, 1);
        matchedReadings_.erase(mit);
    }
    delete reading;
}

#pragma SPL_NON_GENERIC_OPERATOR_IMPLEMENTATION_EPILOGUE
