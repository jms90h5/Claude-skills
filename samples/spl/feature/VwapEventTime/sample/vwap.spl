// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// THIS SAMPLE CODE IS PROVIDED ON AN "AS IS" BASIS.                
// TERACLOUD APS AND IBM MAKES NO REPRESENTATIONS OR WARRANTIES,    
// EXPRESS OR IMPLIED, CONCERNING  USE OF THE SAMPLE CODE, OR THE   
// COMPLETENESS OR ACCURACY OF THE SAMPLE CODE. TERACLOUD APS       
// AND IBM DOES NOT WARRANT UNINTERRUPTED OR ERROR-FREE OPERATION   
// OF THIS SAMPLE CODE. TERACLOUD APS AND IBM IS NOT RESPONSIBLE FOR THE 
// RESULTS OBTAINED FROM THE USE OF THE SAMPLE CODE OR ANY PORTION  
// OF THIS SAMPLE CODE.                                             
//                                                                  
// LIMITATION OF LIABILITY. IN NO EVENT WILL IBM BE LIABLE TO ANY   
// PARTY FOR ANY DIRECT, INDIRECT, SPECIAL OR OTHER CONSEQUENTIAL   
// DAMAGES FOR ANY USE OF THIS SAMPLE CODE, THE USE OF CODE FROM    
// THIS [ SAMPLE PACKAGE,] INCLUDING, WITHOUT LIMITATION, ANY LOST  
// PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA   
// ON YOUR INFORMATION HANDLING SYSTEM OR OTHERWISE.                
//                                                                  
// (C) Copyright Teracloud ApS 2024, 2025, IBM Corp. 2018, 2018     
// All Rights reserved.                                             
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 

/** 
 * Computes the volume-weighted average price (VWAP) for a stream of stock 
 * transactions. Given trades and quotes, this application produces a 
 * bargain index for a given list of stocks.  The WVAP is calculated over 
 * event-time intervals of 10 seconds and is calculated every second. 
 * The average is not recalculated if late trades are received (tuples
 * are ignored).
 * 
 * The bargain index identifies possible trade opportunities, which occur 
 * when the volume-weighted average price for trades executed within the 
 * last 10 seconds exceeds the current ask price. This algorithm may be 
 * used to identify opportunities to pick up well priced shares in the 
 * stream of current transaction data.
 * 
 * Executed with default arguments, the application selects trades and quotes
 * for a set of ticker symbols from an input file containing a snapshot of 
 * transaction data.  The ticker symbols to be selected may be changed by 
 * updating the `$monitoredTickers` parameter in the `VwapEventTime` 
 * composite operator.
 */
                       
namespace sample;

/** 
 * Returns true if the transaction type is a quote, and false otherwise.
 * @param ttype transaction type
 * @return true if the transaction is a quote and false otherwise.
 */
boolean isQuote(rstring ttype) 
{
  return ttype=="Quote"; 
}

/** 
 * Returns true if the transaction type is a trade, and false otherwise.
 * @param ttype transaction type
 * @return true if the transaction is a trade and false otherwise.
 */
boolean isTrade(rstring ttype) 
{
  return ttype=="Trade"; 
}

/**
 * Given an input file containing trades and quotes, this composite operator 
 * produces an output file called out in the toolkit's data directory.
 * The output file lists the VWAP and bargain index for the last 4 trades. The
 * trades included in the VWAP computation are grouped by the Aggregate 
 * operator, which uses a sliding window to sum the weighted price and volume 
 * for the 4 most recent transactions.
 * 
 * The bargain index identifies the magnitude of the bargain, where a greater 
 * values implies a better bargain. A value of 0 indicates that the VWAP is 
 * not greater than the asking price, and is therefore not a bargain.
 * 
 * A few records from the output file are show below:
 *
 * {ticker="BK",vwap=32.51,askprice=32.51,asksize=50,date="27-DEC-2005",time="14:30:17.098",index=0}
 * {ticker="BK",vwap=32.51,askprice=32.51,asksize=48,date="27-DEC-2005",time="14:30:17.100",index=0}
 * {ticker="IBM",vwap=83.47991935483871,askprice=83.46,asksize=10,date="27-DEC-2005",time="14:30:17.238",index=10.20119069042564}
 * {ticker="IBM",vwap=83.47991935483871,askprice=83.46,asksize=10,date="27-DEC-2005",time="14:30:17.238",index=10.20119069042564}
 *
 * These output records are produced by the `FileSink` operator. Each record 
 * shows the contents of the tuples received on the `BargainIndex` stream as a
 * set of tuple attributes. The attributes are formatted as a key-value pair. 
 * The `vwap` and `index` attributes contains the value-weighted average price
 * and bargain index, respectively.
 * 
 * @param monitoredTickers the set of ticker symbols to select.
 *        The symbols are space delimited.  
 */
composite VwapEventTime {
  param 
    expression<set<rstring>> $monitoredTickers : { "BK", "IBM", "ANR" };

  type
    TQRecT = rstring ticker,rstring date, rstring time, int32 gmtOffset, 
             rstring ttype, rstring exCntrbID, decimal64 price, 
             decimal64 volume, decimal64 vwap, rstring buyerID, 
             decimal64 bidprice, decimal64 bidsize, int32 numbuyers,
             rstring sellerID, decimal64 askprice, decimal64 asksize, 
             int32 numsellers, rstring qualifiers, int32 seqno, 
             rstring exchtime, decimal64 blockTrd, decimal64 floorTrd, 
             decimal64 PEratio, decimal64 yield, decimal64 newprice,
             decimal64 newvol, int32 newseqno, decimal64 bidimpvol, 
             decimal64 askimpcol, decimal64 impvol;

    /* Parse 'date' and 'time' into event-time 'evTime' */
    TQRecWithTST = rstring ticker, rstring date, rstring time, 
             timestamp evTime, int32 gmtOffset, 
             rstring ttype, rstring exCntrbID, decimal64 price, 
             decimal64 volume, decimal64 vwap, rstring buyerID, 
             decimal64 bidprice, decimal64 bidsize, int32 numbuyers,
             rstring sellerID, decimal64 askprice, decimal64 asksize, 
             int32 numsellers, rstring qualifiers, int32 seqno, 
             rstring exchtime, decimal64 blockTrd, decimal64 floorTrd, 
             decimal64 PEratio, decimal64 yield, decimal64 newprice,
             decimal64 newvol, int32 newseqno, decimal64 bidimpvol, 
             decimal64 askimpcol, decimal64 impvol;
    
    TradeInfoT = decimal64 price, decimal64 volume, rstring date, rstring time;
    QuoteInfoT = decimal64 bidprice, decimal64 askprice, decimal64 asksize,
             rstring date, rstring time;
    TradeFilterT = TradeInfoT, tuple<timestamp evTime, rstring ticker>;
    QuoteFilterT = QuoteInfoT, tuple<timestamp evTime, rstring ticker>;
    VwapT =  rstring ticker, decimal64 minprice, decimal64 maxprice, 
             decimal64 avgprice, decimal64 vwap, timestamp start, timestamp end;
    BargainIndexT = rstring ticker, decimal64 vwap, decimal64 askprice, 
             decimal64 asksize, rstring date, rstring time, decimal64 index;

  graph

    stream<TQRecT> TradeQuoteRaw = FileSource() 
    {
      param
        file : "TradesAndQuotes.csv.gz";
        format : csv;
        compression : gzip;
    }

    /* Event-time source, creates watermarks from submitted 'evTime' values */ 
    @eventTime(eventTimeAttribute=evTime)
    stream<TQRecWithTST> TradeQuote = Functor(TradeQuoteRaw) 
    {
      output
        TradeQuote : evTime = timeStringToTimestamp(date, time, false);
    }

    stream<TradeFilterT> TradeFilter = Functor(TradeQuote) 
    {
      param
        filter : isTrade(ttype) && (ticker in $monitoredTickers);
    }

    stream<QuoteFilterT> QuoteFilter = Functor(TradeQuote) 
    {
      param
        filter : isQuote(ttype) && (ticker in $monitoredTickers);
    }

    /* Aggregation over event-time intervals of 10 seconds, calculated every 
     * second. Late tuples are ignored.
     */
    stream<VwapT, tuple<decimal64 sumvolume>> PreVwap = Aggregate(TradeFilter) 
    {
      window
        TradeFilter : timeInterval, intervalDuration(10.0), creationPeriod(1.0), partitioned;
      param
        partitionBy : ticker;
      output
        PreVwap : ticker = Any(ticker), vwap = Sum(price * volume), minprice = Min(price), 
                  maxprice = Max(price), avgprice = Average(price), sumvolume = Sum(volume),
                  start = intervalStart(), end = intervalEnd();
    }

    stream<VwapT> Vwap = Functor(PreVwap) 
    {
      output
        Vwap : vwap = vwap / sumvolume;
    }

    /* Join quotes with an event-time up to one second greater than the WVAP time */
    stream<BargainIndexT> BargainIndex = Join(Vwap as V; QuoteFilter as Q) 
    {
      window
        V : sliding, count(1), partitioned;
        Q : sliding, count(0);
      param
        partitionByLHS : V.ticker;
        equalityLHS    : V.ticker;
        equalityRHS    : Q.ticker;
        match : (V.end <= Q.evTime) && (Q.evTime < add(V.end, (float64)1.0)) ;
      output
        BargainIndex : index = vwap > askprice ? asksize * exp(vwap - askprice) : 0d;
    }

    () as SinkOp = FileSink(BargainIndex) 
    {
        param
          file : "out";
          format : txt;
    }
}
