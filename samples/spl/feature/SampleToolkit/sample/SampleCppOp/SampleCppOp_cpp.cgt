// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// THIS SAMPLE CODE IS PROVIDED ON AN "AS IS" BASIS.                
// TERACLOUD APS AND IBM MAKES NO REPRESENTATIONS OR WARRANTIES,    
// EXPRESS OR IMPLIED, CONCERNING  USE OF THE SAMPLE CODE, OR THE   
// COMPLETENESS OR ACCURACY OF THE SAMPLE CODE. TERACLOUD APS       
// AND IBM DOES NOT WARRANT UNINTERRUPTED OR ERROR-FREE OPERATION   
// OF THIS SAMPLE CODE. TERACLOUD APS AND IBM IS NOT RESPONSIBLE FOR THE     
// RESULTS OBTAINED FROM THE USE OF THE SAMPLE CODE OR ANY PORTION   
// OF THIS SAMPLE CODE.                                              
//                                                                   
// LIMITATION OF LIABILITY. IN NO EVENT WILL IBM BE LIABLE TO ANY    
// PARTY FOR ANY DIRECT, INDIRECT, SPECIAL OR OTHER CONSEQUENTIAL    
// DAMAGES FOR ANY USE OF THIS SAMPLE CODE, THE USE OF CODE FROM     
// THIS [ SAMPLE PACKAGE,] INCLUDING, WITHOUT LIMITATION, ANY LOST   
// PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA    
// ON YOUR INFORMATION HANDLING SYSTEM OR OTHERWISE.                 
//                                                                   
// (C) Copyright Teracloud ApS 2024, 2024, IBM Corp. 2010, 2012     
// All Rights reserved.                                             
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 
/* Additional includes go here */

#pragma SPL_NON_GENERIC_OPERATOR_IMPLEMENTATION_PROLOGUE

/* Additional includes can go here as well */

// Constructor
MY_OPERATOR::MY_OPERATOR()
{
    // Initialization code goes here    
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
    // Finalization code goes here
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
    // Notifies that all ports are ready. No tuples should be submitted before
    // this. Source operators can use this method to spawn threads.

    /*
      createThreads(1); // Create source thread
    */
}
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
    // This is an asynchronous call
}

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx)
{
    // A typical implementation will loop until shutdown
    /*
      while(!getPE().getShutdownRequested()) {
          // do work ...
      }
    */
}

// Tuple processing for mutating ports 
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
    // Sample submit code
    /* 
      submit(otuple, 0); // submit to output port 0
    */
    // Sample cast code
    /*
    switch(port) {
    case 0: { 
      IPort0Type & ituple = static_cast<IPort0Type&>(tuple);
      ...
    } break;
    case 1: { 
      IPort1Type & ituple = static_cast<IPort1Type&>(tuple);
      ...
    } break;
    default: ...
    }
    */
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
    // Sample submit code
    /* 
      OPort0Type otuple;
      submit(otuple, 0); // submit to output port 0
    */
    // Sample cast code
    /*
    switch(port) {
    case 0: { 
      IPort0Type const & ituple = static_cast<IPort0Type const&>(tuple);
      ...
    } break;
    case 1: { 
      IPort1Type const & ituple = static_cast<IPort1Type const&>(tuple);
      ...
    } break;
    default: ...
    }
    */
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
    /*
      if(punct==Punctuation::WindowMarker) {
        // ...;
      } else if(punct==Punctuation::FinalMarker) {
        // ...;
      }
    */
}

#pragma SPL_NON_GENERIC_OPERATOR_IMPLEMENTATION_EPILOGUE
