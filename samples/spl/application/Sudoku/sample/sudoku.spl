// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// THIS SAMPLE CODE IS PROVIDED ON AN "AS IS" BASIS.                
// TERACLOUD APS AND IBM MAKES NO REPRESENTATIONS OR WARRANTIES,    
// EXPRESS OR IMPLIED, CONCERNING  USE OF THE SAMPLE CODE, OR THE   
// COMPLETENESS OR ACCURACY OF THE SAMPLE CODE. TERACLOUD APS       
// AND IBM DOES NOT WARRANT UNINTERRUPTED OR ERROR-FREE OPERATION   
// OF THIS SAMPLE CODE. TERACLOUD APS AND IBM IS NOT RESPONSIBLE FOR THE 
// RESULTS OBTAINED FROM THE USE OF THE SAMPLE CODE OR ANY PORTION  
// OF THIS SAMPLE CODE.                                             
//                                                                  
// LIMITATION OF LIABILITY. IN NO EVENT WILL IBM BE LIABLE TO ANY   
// PARTY FOR ANY DIRECT, INDIRECT, SPECIAL OR OTHER CONSEQUENTIAL   
// DAMAGES FOR ANY USE OF THIS SAMPLE CODE, THE USE OF CODE FROM    
// THIS [ SAMPLE PACKAGE,] INCLUDING, WITHOUT LIMITATION, ANY LOST  
// PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA   
// ON YOUR INFORMATION HANDLING SYSTEM OR OTHERWISE.                
//                                                                  
// (C) Copyright Teracloud ApS 2024, 2025, IBM Corp. 2010, 2014     
// All Rights reserved.                                             
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 
namespace sample;
use sample.sudoku::*; // Native function for sudoku solver
use spl.file::*;

composite Sudoku 
{
  param expression<rstring> $file : getSubmissionTimeValue("file", "");
  graph
    stream<rstring file> File = Beacon() 
    {
        param iterations : 1u;
        output File : file = getFileName($file);
    }       
    stream<rstring unsolved> Src = FileSource(File) {} 
    stream<rstring solved> Res = Functor(Src)
    {
        logic state : mutable int32 error1 = 0, error2=0;
        output Res: solved = sideBySide(format(unsolved, error1), 
                                        solve(unsolved, error2))+"\n";
    }
    () as Writer = FileSink(Res) 
    {
        param file : "/dev/stdout";
              quoteStrings : false;
    }
}

// return file name as is, if non-empty
// otherwise, generate a file and return its name
stateful rstring getFileName(rstring file)
{
    if(length(file)!=0)
        return file;
    mutable int32 err = 0;
    rstring unsolved = sudokuRandom(); // SPL function for sudoku generator (see shuffler.spl)
    rstring autoFile = dataDirectory() + "/random_input.txt";
    uint64 fd = fopen(autoFile, "w", err);
    fwriteString(unsolved, fd, err);
    fwriteString("\n", fd, err);
    fclose(fd, err);
    return autoFile;
}

// print two sudoku boards side-by-side into a string
rstring sideBySide(rstring lhs, rstring rhs)
{
    list<rstring> tokensLhs = tokenize(lhs, "\n", false);
    list<rstring> tokensRhs = tokenize(rhs, "\n", false);
    assert(size(tokensLhs)==size(tokensRhs));
    mutable int32 i = 0, s = size(tokensLhs);
    mutable rstring result = "";
    while(i<s) {
        result += tokensLhs[i] + "\t" + tokensRhs[i] + "\n"; 
        ++i;
    }
    return result;
}


