// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// THIS SAMPLE CODE IS PROVIDED ON AN "AS IS" BASIS.                
// TERACLOUD APS AND IBM MAKES NO REPRESENTATIONS OR WARRANTIES,    
// EXPRESS OR IMPLIED, CONCERNING  USE OF THE SAMPLE CODE, OR THE   
// COMPLETENESS OR ACCURACY OF THE SAMPLE CODE. TERACLOUD APS       
// AND IBM DOES NOT WARRANT UNINTERRUPTED OR ERROR-FREE OPERATION   
// OF THIS SAMPLE CODE. TERACLOUD APS AND IBM IS NOT RESPONSIBLE FOR THE 
// RESULTS OBTAINED FROM THE USE OF THE SAMPLE CODE OR ANY PORTION  
// OF THIS SAMPLE CODE.                                             
//                                                                  
// LIMITATION OF LIABILITY. IN NO EVENT WILL IBM BE LIABLE TO ANY   
// PARTY FOR ANY DIRECT, INDIRECT, SPECIAL OR OTHER CONSEQUENTIAL   
// DAMAGES FOR ANY USE OF THIS SAMPLE CODE, THE USE OF CODE FROM    
// THIS [ SAMPLE PACKAGE,] INCLUDING, WITHOUT LIMITATION, ANY LOST  
// PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA   
// ON YOUR INFORMATION HANDLING SYSTEM OR OTHERWISE.                
//                                                                  
// (C) Copyright Teracloud ApS 2024, 2025, IBM Corp. 2011, 2015     
// All Rights reserved.                                             
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 
namespace teda.sample.StructureParse.Basic;

use com.teracloud.streams.teda.parser.binary::StructureParse;

/** Sample application to demonstrate basic features of the StructureParse operator

    This sample parses a binary data file located in the data directory. The file is 
    read by the FileSource operator and the content is passed in 1MB blocks to the parser
    operator. The output tuples from the parser are than written to a file named "output.txt"
    in the data directory. This sample demonstrates the usage of different data types
    in the binary record, either in big endian or little endian format and how to apply
    the toString() element to convert integer values into rstring attributes.
    For more details, see the comments in the XML documents (in the etc directory).

*/
composite Main 
{

	type
		Data = tuple
		<
			// integral types with little-endian (x86)
			uint8 	uintval8,
			uint16 	uintval16,			
			uint32 	uintval32,
			uint64	uintval64,
			int8	intval8,
			int16	intval16,
			int32	intval32,
			int64	intval64,
			
			// some integrals with big-endian (power)
			uint16	uintval16_be,
			uint32	uintval32_be,
			
			// some floats
			float32	floatval32,
			float64	floatval64,
			
			// a string
			rstring stringval1,
			
			// some strings with conversions from the integers above
			rstring stringconv1,
			rstring stringconv2,
			rstring stringconv3
		>;

	graph
		
		/**
		 * Read the binary data from file, output the data as blobs
		 */
		stream<rstring filename, int64 tupleNo, blob payload> SourceData as O = FileSource()
		{
			param
				file: "input.bin";
				format: block;
				blockSize: 1024u * 1024u;
			output O:
				filename = FileName(),
				tupleNo = TupleNumber();
		}
		
		/**
		 * Decode the binary records according to the configured mapping
		 */
		stream<Data> Output as O = StructureParse(SourceData as I)
		{
			param
				payloadAttribute : payload;
				structureDocument : "etc/structure.xml";
				mappingDocument : "etc/mapping.xml";
		}
		
		/**
		 * Write decoded records to a text file
		 */
		() as Sink = FileSink(Output as I)
		{
			param
				file: "output.txt";
			 	format: txt;
			 	flush: 1u;
		}

}

