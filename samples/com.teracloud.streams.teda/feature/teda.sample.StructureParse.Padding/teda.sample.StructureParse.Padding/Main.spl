// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// THIS SAMPLE CODE IS PROVIDED ON AN "AS IS" BASIS.                
// TERACLOUD APS AND IBM MAKES NO REPRESENTATIONS OR WARRANTIES,    
// EXPRESS OR IMPLIED, CONCERNING  USE OF THE SAMPLE CODE, OR THE   
// COMPLETENESS OR ACCURACY OF THE SAMPLE CODE. TERACLOUD APS       
// AND IBM DOES NOT WARRANT UNINTERRUPTED OR ERROR-FREE OPERATION   
// OF THIS SAMPLE CODE. TERACLOUD APS AND IBM IS NOT RESPONSIBLE FOR THE 
// RESULTS OBTAINED FROM THE USE OF THE SAMPLE CODE OR ANY PORTION  
// OF THIS SAMPLE CODE.                                             
//                                                                  
// LIMITATION OF LIABILITY. IN NO EVENT WILL IBM BE LIABLE TO ANY   
// PARTY FOR ANY DIRECT, INDIRECT, SPECIAL OR OTHER CONSEQUENTIAL   
// DAMAGES FOR ANY USE OF THIS SAMPLE CODE, THE USE OF CODE FROM    
// THIS [ SAMPLE PACKAGE,] INCLUDING, WITHOUT LIMITATION, ANY LOST  
// PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA   
// ON YOUR INFORMATION HANDLING SYSTEM OR OTHERWISE.                
//                                                                  
// (C) Copyright Teracloud ApS 2024, 2025, IBM Corp. 2011, 2015     
// All Rights reserved.                                             
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 
namespace teda.sample.StructureParse.Padding;

use com.teracloud.streams.teda.parser.binary::StructureParse;

/**
 * The sample application demonstrates the use of the StructureParse operator
 * for the treatment of padding bytes, which can occur between structures, in
 * this case between trailer and header structures.
 */
composite Main
{
	type
		Action = enum { punctuation, data };
		Item = tuple
		<
			Action action,
			blob payload
		>;
		Data = tuple
		<
			uint8 id,
			uint8 index
		>;
		Metric = tuple
		<
			uint64 nTuplesReceived,
			uint64 nTuplesSent,
			uint64 nBytesReceived,
			uint64 nBytesDropped,
			uint64 nPaddingCount,
			uint64 nPaddingByteCount,
			map<rstring,uint64> counts,
			map<rstring,uint64> bytes,
			map<rstring,map<rstring,uint64>> stats
		>;
	graph
		/**
		 * Generate the payload data.
		 * header      : uint8 type[0], uint8 index
		 * trailer     : uint8 type[1], uint8 index
		 * payload     : uint8[n] byte[0xFF]
		 */
		stream<blob payload> SourceData as O = Custom()
		{
			logic
			state:
			{
				list<Item> control =
				[
					// --------------------------------------------------------
					// PADDING (multiple tuples)
					// --------------------------------------------------------
					{ action = Action.data, payload = (blob)[ 255ub ] },
					{ action = Action.data, payload = (blob)[ 255ub, 255ub ] },
					{ action = Action.data, payload = (blob)[ 255ub, 255ub, 255ub ] },
					// --------------------------------------------------------
					// HEADER, TRAILER, PADDING as separate tuples
					// --------------------------------------------------------
					{ action = Action.data, payload = (blob)[ 0ub, 1ub ] },
					{ action = Action.data, payload = (blob)[ 1ub, 1ub ] },
					{ action = Action.data, payload = (blob)[ 255ub, 255ub ] },
					// --------------------------------------------------------
					// PADDING, HEADER, TRAILER, PADDING in one tuple
					// followed by HEADER, TRAILER in another tuple
					// --------------------------------------------------------
					{ action = Action.data, payload = (blob)[ 255ub, 0ub, 2ub, 1ub, 2ub, 255ub ] },
					{ action = Action.data, payload = (blob)[ 0ub, 3ub, 1ub, 3ub ] },
					// --------------------------------------------------------
					// several HEADER, TRAILER blocks without PADDING
					// --------------------------------------------------------
					{ action = Action.data, payload = (blob)[ 0ub, 4ub, 1ub, 4ub ] },
					{ action = Action.data, payload = (blob)[ 0ub, 5ub, 1ub, 5ub ] },
					{ action = Action.data, payload = (blob)[ 0ub, 6ub, 1ub, 6ub ] },
					// --------------------------------------------------------
					// PUNCTUATION
					// --------------------------------------------------------
					{ action = Action.punctuation, payload = (blob)[] },
					// --------------------------------------------------------
					// PADDING, no data
					// --------------------------------------------------------
					{ action = Action.data, payload = (blob)[ 255ub, 255ub, 255ub ] },
					// --------------------------------------------------------
					// PUNCTUATION
					// --------------------------------------------------------
					{ action = Action.punctuation, payload = (blob)[] }
				];
			}
			onProcess:
			{
				for (Item item in control)
				{
					if (item.action == Action.punctuation)
					{
						submit(Sys.WindowMarker, O);
					}
					else
					{
						submit({payload = item.payload}, O);
					}
				}
			}
		}
		/**
		 * Decode the binary records according to the configured structures and
		 * mapping.
		 */
		(stream<Data> Outputs as O; stream<Metric> Metrics as M) as Parse = StructureParse(SourceData as I)
		{
			param
				structureDocument : "etc/structure.xml";
				mappingDocument : "etc/mapping.xml";
			output M:
				nTuplesReceived = nTuplesReceived(),
				nTuplesSent = nTuplesSent(),
				nBytesReceived = nBytesReceived(),
				nBytesDropped = nBytesDropped(),
				nPaddingCount = getRecordCount("padding"),
				nPaddingByteCount = getRecordByteCount("padding"),
				counts = getRecordCounts(),
				bytes = getRecordByteCounts(),
				stats = getRecordStats()
				;
		}
		
		/**
		 * Write decoded records to text file.
		 */
		() as OutputsSink = FileSink(Outputs as I)
		{
			param
				file: "outputs.txt";
				format: txt;
				flush: 1u;
				writePunctuations: true;
		}
		/**
		 * Write metrics to text file.
		 */
		() as MetricsSink = FileSink(Metrics as I)
		{
			param
				file: "metrics.txt";
				format: txt;
				flush: 1u;
				writePunctuations: true;
		}
}
