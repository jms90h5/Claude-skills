// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// THIS SAMPLE CODE IS PROVIDED ON AN "AS IS" BASIS.                
// TERACLOUD APS AND IBM MAKES NO REPRESENTATIONS OR WARRANTIES,    
// EXPRESS OR IMPLIED, CONCERNING  USE OF THE SAMPLE CODE, OR THE   
// COMPLETENESS OR ACCURACY OF THE SAMPLE CODE. TERACLOUD APS       
// AND IBM DOES NOT WARRANT UNINTERRUPTED OR ERROR-FREE OPERATION   
// OF THIS SAMPLE CODE. TERACLOUD APS AND IBM IS NOT RESPONSIBLE FOR THE 
// RESULTS OBTAINED FROM THE USE OF THE SAMPLE CODE OR ANY PORTION  
// OF THIS SAMPLE CODE.                                             
//                                                                  
// LIMITATION OF LIABILITY. IN NO EVENT WILL IBM BE LIABLE TO ANY   
// PARTY FOR ANY DIRECT, INDIRECT, SPECIAL OR OTHER CONSEQUENTIAL   
// DAMAGES FOR ANY USE OF THIS SAMPLE CODE, THE USE OF CODE FROM    
// THIS [ SAMPLE PACKAGE,] INCLUDING, WITHOUT LIMITATION, ANY LOST  
// PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA   
// ON YOUR INFORMATION HANDLING SYSTEM OR OTHERWISE.                
//                                                                  
// (C) Copyright Teracloud ApS 2024, 2025, IBM Corp. 2011, 2015     
// All Rights reserved.                                             
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 
namespace teda.sample.StructureParse.Versioning;

use com.teracloud.streams.teda.parser.binary::StructureParse;

/**
 * Return the character code of the string's 1st character.
 */
uint8 code(rstring value)
{
	return (uint8)toCharacterCode(value);
}

/**
 * The sample application demonstrates the use of the StructureParse operator
 * for the treatment of different versions of data structures. The version
 * information is stored in a header structure and is not available in the
 * payload structures.
 *
 * First, a version 0 structure block is processed, followed by a version 1
 * structure block. Afterward, a structure block with version 0 and version 1
 * structures is received, which fails and leads to structure-based
 * synchronization. Afterwards, some final valid but empty structure blocks
 * are handled.
 * 
 * To synchronize, the algorithm requires at least N bytes, whereas N is the
 * size of the largest structure.
 */
composite Main
{
	type
		Action = enum { punctuation, data };
		Item = tuple
		<
			Action action,
			blob payload
		>;
		Data = tuple
		<
			uint8 id,
			uint16 version,
			rstring originator,
			rstring destination,
			rstring smsCenter,
			rstring imsi
		>;
		Metric = tuple
		<
			uint64 nTuplesReceived,
			uint64 nTuplesSent,
			uint64 nBytesReceived,
			uint64 nBytesDropped
		>;
	graph
		/**
		 * Generate the payload data.
		 * header      : uint8 type[0], uint16 version
		 * event A (v0): uint8 type[1], rstring[3] originator, rstring[3] destination
		 * event A (v1): uint8 type[1], rstring[3] originator, rstring[3] destination, rstring[3] imsi
		 * event B (v0): uint8 type[2], rstring[3] smsCenter
		 * event B (v1): uint8 type[2], rstring[3] smsCenter, rstring[3] imsi
		 * trailer     : uint8 type[3]
		 */
		stream<blob payload> SourceData as O = Custom()
		{
			logic
			state:
			{
				list<Item> control =
				[
					// --------------------------------------------------------
					// VALID RECORD BLOCK, VERSION 0
					// --------------------------------------------------------
					// header: version=0
					{ action = Action.data, payload = (blob)[ 0ub, /* version */ 0ub, 0ub ] },
					// event A (v0)
					{ action = Action.data, payload = (blob)
						[
							1ub,
							/* originator */ code("O"), code("R"), code("G"),
							/* destination */ code("D"), code("S"), code("T")
						]
					},
					// event B (v0)
					{ action = Action.data, payload = (blob)
						[
							2ub,
							/* SMS center */ code("S"), code("M"), code("S")
						]
					},
					// trailer
					{ action = Action.data, payload = (blob)[ 3ub ] },
					// --------------------------------------------------------
					// VALID RECORD BLOCK, VERSION 1
					// --------------------------------------------------------
					// header: version=1
					{ action = Action.data, payload = (blob)[ 0ub, /* version */ 1ub, 0ub ] },
					// event A (v1)
					{ action = Action.data, payload = (blob)
						[
							1ub,
							/* originator */ code("O"), code("R"), code("G"),
							/* destination */ code("D"), code("S"), code("T"),
							/* imsi */ code("A"), code("0"), code("0")
						]
					},
					// event B (v1)
					{ action = Action.data, payload = (blob)
						[
							2ub,
							/* SMS center */ code("S"), code("M"), code("S"),
							/* imsi */ code("B"), code("0"), code("0")
						]
					},
					// trailer
					{ action = Action.data, payload = (blob)[ 3ub ] },
					// --------------------------------------------------------
					// INVALID RECORD BLOCK, MIXED VERSIONS
					// --------------------------------------------------------
					// header: version=0
					{ action = Action.data, payload = (blob)[ 0ub, /* version */ 0ub, 0ub ] },
					// event A (v0)
					{ action = Action.data, payload = (blob)
						[
							1ub,
							/* originator */ code("O"), code("R"), code("G"),
							/* destination */ code("D"), code("S"), code("T")
						]
					},
					// event A (v1)
					{ action = Action.data, payload = (blob)
						[
							1ub,
							/* originator */ code("O"), code("R"), code("G"),
							/* destination */ code("D"), code("S"), code("T"),
							/* imsi */ code("A"), code("0"), code("0")
						]
					},
					// event B (v0)
					{ action = Action.data, payload = (blob)
						[
							2ub,
							/* SMS center */ code("S"), code("M"), code("S")
						]
					},
					// trailer
					{ action = Action.data, payload = (blob)[ 3ub ] },
					// --------------------------------------------------------
					// VALID BUT EMPTY RECORD BLOCKS, VERSION 1
					// --------------------------------------------------------
					// To synchronize, the algorithm requires at least N bytes,
					// whereas N is the size of the largest structure.
					// --------------------------------------------------------
					// header: version=1 followed by trailer
					{ action = Action.data, payload = (blob)[ 0ub, /* version */ 1ub, 0ub, 3ub ] },
					{ action = Action.data, payload = (blob)[ 0ub, /* version */ 1ub, 0ub, 3ub ] },
					{ action = Action.data, payload = (blob)[ 0ub, /* version */ 1ub, 0ub, 3ub ] },
					{ action = Action.data, payload = (blob)[ 0ub, /* version */ 1ub, 0ub, 3ub ] },
					{ action = Action.data, payload = (blob)[ 0ub, /* version */ 1ub, 0ub, 3ub ] },
					// --------------------------------------------------------
					// PUNCTUATION
					// --------------------------------------------------------
					{ action = Action.punctuation, payload = (blob)[] }
				];
			}
			onProcess:
			{
				for (Item item in control)
				{
					if (item.action == Action.punctuation)
					{
						submit(Sys.WindowMarker, O);
					}
					else
					{
						submit({payload = item.payload}, O);
					}
				}
			}
		}
		/**
		 * Decode the binary records according to the configured structures and
		 * mapping.
		 */
		(stream<Data> Outputs as O; stream<Metric> Metrics as M) as Parse = StructureParse(SourceData as I)
		{
			param
				structureDocument : "etc/structure.xml";
				mappingDocument : "etc/mapping.xml";
			output M:
				nTuplesReceived = nTuplesReceived(),
				nTuplesSent = nTuplesSent(),
				nBytesReceived = nBytesReceived(),
				nBytesDropped = nBytesDropped()
				;
		}
		
		/**
		 * Write decoded records to text file.
		 */
		() as OutputsSink = FileSink(Outputs as I)
		{
			param
				file: "outputs.txt";
				format: txt;
				flush: 1u;
				writePunctuations: true;
		}
		/**
		 * Write metrics to text file.
		 */
		() as MetricsSink = FileSink(Metrics as I)
		{
			param
				file: "metrics.txt";
				format: txt;
				flush: 1u;
				writePunctuations: true;
		}
}
