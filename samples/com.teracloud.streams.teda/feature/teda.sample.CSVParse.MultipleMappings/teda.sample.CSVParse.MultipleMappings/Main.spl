// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// THIS SAMPLE CODE IS PROVIDED ON AN "AS IS" BASIS.                
// TERACLOUD APS AND IBM MAKES NO REPRESENTATIONS OR WARRANTIES,    
// EXPRESS OR IMPLIED, CONCERNING  USE OF THE SAMPLE CODE, OR THE   
// COMPLETENESS OR ACCURACY OF THE SAMPLE CODE. TERACLOUD APS       
// AND IBM DOES NOT WARRANT UNINTERRUPTED OR ERROR-FREE OPERATION   
// OF THIS SAMPLE CODE. TERACLOUD APS AND IBM IS NOT RESPONSIBLE FOR THE 
// RESULTS OBTAINED FROM THE USE OF THE SAMPLE CODE OR ANY PORTION  
// OF THIS SAMPLE CODE.                                             
//                                                                  
// LIMITATION OF LIABILITY. IN NO EVENT WILL IBM BE LIABLE TO ANY   
// PARTY FOR ANY DIRECT, INDIRECT, SPECIAL OR OTHER CONSEQUENTIAL   
// DAMAGES FOR ANY USE OF THIS SAMPLE CODE, THE USE OF CODE FROM    
// THIS [ SAMPLE PACKAGE,] INCLUDING, WITHOUT LIMITATION, ANY LOST  
// PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA   
// ON YOUR INFORMATION HANDLING SYSTEM OR OTHERWISE.                
//                                                                  
// (C) Copyright Teracloud ApS 2024, 2025, IBM Corp. 2011, 2015     
// All Rights reserved.                                             
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 
namespace teda.sample.CSVParse.MultipleMappings;
use com.teracloud.streams.teda.parser.text::CSVParse;

/**
 * This sample demonstrates the usage of multiple mappings with the CSVParse operator. It uses a FileSource operator to read the CSV input file data/input.csv
 * The CSV lines are send to the CSVParse operator, that parses each line and assigns the CSV fields to attributes of the ColorsAndShapes type.
 * 
 * The input CSV file contains to different record types : COLOR records and SHAPE records : 
 * 
 * COLOR,Red,255,0,0
 * SHAPE,Rectangle,0,0,100,100
 * COLOR,Green,0,255,0
 * SHAPE,Circle,10.2,-13.8,100
 *
 * The color records are the same type as dor the CSVParse basic sample, holding the RGB values of the colors. The shape records contain fields
 * for the shape name and x and y coordinates. For each of the input records an output tuple of type ColorsAndShapes is emitted. This type
 * contains a superset of the fields in both record types. The mapping document specifies which CSV field is assigned to which output 
 * attribute for each record type.
 *  
 * For more information on this sample, see the SPLDOC of the CSVParse operator.
 * 
 */
composite Main
{
	type
	
		/**
		 * The type of the unified output tuple. It contains an rstring that holds the record type, the 3 RGB values from COLOR records,
		 * and the shape name and coordinates for SHAPE records. For COLOR records, the shape related attributes get their default values,
		 * for SHAPE records the color related attributes get their defaults.
		 */
		ColorsAndShapes = tuple
		<
			rstring recordType,
			uint8 R,
			uint8 G,
			uint8 B,
			rstring shapeName,
			float64 xCoordinate,
			float64 yCoordinate
		>;

		/**
		 * The type of the statistics tuple. For each mapping in the mappingDocument an entry is present in the map.
		 * the value of this entry is another map that contains the statistic counters with countername->countervalue pairs.
		 * For this sample we will see 2 SHAPE records and 2 COLOR records. The statistic tuple emitted on punctuation will
		 * look like this :
		 * {recordStats={"shapes":{"errors":0,"records":2},"colors":{"errors":0,"records":2}}}
		 * For each mapping ("shapes" and "colors") there are two counters. The records counter contains the number of
		 * successfully processed records for this mapping. The errors counter contains the number of failed records
		 * for this mapping (either due to conversion problems or item count validation failures).
		 */
		StatisticTuple = tuple
		<
			map<rstring, map<rstring , uint64 >> recordStats
		>;

	graph

		/**
		 * Read the input csv file. Each line is submitted as an rstring
		 */
		stream<rstring csvline> Content as O = FileSource()
		{
			param
				file: "input.csv";
				format: line;
		}
	
		/**
		 * Parse the lines from the FileSource. Valid records are mapped to the output tuple of type ColorsAndShapes.
		 * Invalid records are forwarded to the error port. The mapping document is etc/mapping.xml. The input attribute
		 * that contains the CSV lines is set to the rstring attribute emitted by the FileSource. Empty lines are ignored by default
		 * so they will be dropped and not result in any tuple on output port 0 or 1.
		 * The statistic port is configured to emit record counts for each mapping. The statistic tuple is sent on receipt 
		 * of a window punctuation. 
		 */
		(
			stream<ColorsAndShapes> ParsedContent as O;
			stream<I> ErroneousContent as E;
			stream<StatisticTuple> Statistics as S
		) as Parser = CSVParse(Content as I)
		{
			param
				mappingDocument: "etc/mapping.xml";
				payloadAttribute: csvline;
				metricsMode : punctuation;
			output
				S: recordStats = getRecordStats();
		}

		/**
		 * Valid records are stored in the file data/outputTuples.txt in tuple format.
		 */
		() as OutSink = FileSink(ParsedContent as I)
		{
	            param
	                file : "outputTuples.txt";
	                format : txt;
	    }	

		/**
		 * Invalid records are stored in the file data/errorTuples.txt in tuple format.
		 */
		() as ErrSink = FileSink(ErroneousContent as I)
		{
	            param
	                file : "errorTuples.txt";
	                format : txt;	                
		}
		
		/**
		 * statistic tuples are stored in the file data/statTuples.txt in tuple format.
		 */	
		() as StatSink = FileSink(Statistics as I)
		{
	            param
	                file : "statTuples.txt";
	                format : txt;	                
		}

}
