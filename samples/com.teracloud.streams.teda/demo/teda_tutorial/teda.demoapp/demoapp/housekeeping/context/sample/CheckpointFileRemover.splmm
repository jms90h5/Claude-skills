// begin_generated_IBM_copyright_prolog                            
//                                                                 
// This is an automatically generated copyright prolog.            
// After initializing,  DO NOT MODIFY OR MOVE                      
// ****************************************************************
// Licensed Materials - Property of IBM                            
// 5724-Y95                                                        
// (C) Copyright IBM Corp.  2011, 2025    All Rights Reserved.     
// US Government Users Restricted Rights - Use, duplication or     
// disclosure restricted by GSA ADP Schedule Contract with         
// IBM Corp.                                                       
//                                                                 
// end_generated_IBM_copyright_prolog                              
// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// Licensed Materials - Property of IBM                             
// (C) Copyright Teracloud ApS 2024, 2025, IBM Corp. 2023, 2023     
// All Rights Reserved.                                             
// US Government Users Restricted Rights - Use, duplication or      
// disclosure restricted by GSA ADP Schedule Contract with          
// IBM Corp.                                                        
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 
<% # Switch to Perl scripting mode
	use integer;
	use File::Basename ;
	use File::Spec::Functions qw(catfile catdir) ;
	use FindBin;
	my $toProj=4;
	my $projDir = dirname(__FILE__);
	for (my $i = 0; $i<$toProj; $i++) {
		$projDir=dirname($projDir);
		$projDir=~s/\/$//;
	}
	unshift @INC, catdir($projDir,"scripts");
	require Configurator;
	require CodeGenFrw;
	my $configurator = new Configurator(directory => "$projDir", selector => Configurator::ParameterSet::ITE());

	# -------------------------------------------------------------------------
	# Get mandatory application specific configuration parameters
	# -------------------------------------------------------------------------
	my $contextDisabled = $configurator->isOff(Configurator::ITE_BUSINESSLOGIC_GROUP());
	my $isEnabled = ! $contextDisabled && $configurator->isOn(Configurator::ITE_BUSINESSLOGIC_GROUP_CUSTOM());
	my $ENABLE_CUSTOM_CODE = $configurator->isOff(Configurator::ITE_EMBEDDEDSAMPLECODE());
%>

namespace demoapp.housekeeping.context.sample;

<%if ((1 == $isEnabled) && (0 == $ENABLE_CUSTOM_CODE)) {%>
use demoapp.streams::TypesCommon;

/**
 * Determine from the provided list of existing files those, which are too old
 * or invalid and delete them. Send the input tuples for files that are still
 * valid, to the output port.
 * 
 * The provide algorithm is:
 * A file is too old and gets removed if the file modification date/time is
 * older than the current time minus the value of the secondsToKeep parameter.
 * 
 * @param secondsToKeep
 * The value is specified with the ite.businessLogic.group.custom.timeToKeep
 * parameter.
 * 
 * @param groupId
 * The index of the group. It can be used for debugging or to implement
 * a group-specific removal of checkpoint files.
 * 
 * @input ExistingFiles
 * The CheckpointFileRemover composite operator has a single input port.
 * The punctuation mode of the input port is Expecting.
 * The input port gets a stream of file information (name, size, file
 * modification time) for existing files.
 * 
 * @output KeptFiles
 * The CheckpointFileRemover composite operator has a single output port.
 * The punctuation mode of the output port is Preserving.
 * The output port gets those input tuples, for which the corresponding
 * file is determined to be still valid.
 */
public composite CheckpointFileRemover(input stream<TypesCommon.CheckpointFileRemoverStreamType> ExistingFiles; output stream<TypesCommon.CheckpointFileRemoverStreamType> KeptFiles)
{
	param

		/**
		 * See parameter description in the composite description.
		 */
		expression<int64> $secondsToKeep; // unused in this customized implementation

		/**
		 * The index of the group. It can be used for debugging or to implement
		 * a group-specific removal of checkpoint files.
		 */
		expression<rstring> $groupId;

	graph

		/**
		 * The first file that arrives, triggers the calculation of "now".
		 * Take this time information to split the stream into good and
		 * too old files.
		 */
		@spl_category(name="sample") 
		(stream<I> KeptFiles as G; stream<I> TooOld as B) as Splitter = Filter(ExistingFiles as I)
		{
			logic
			state:
			{
				int64 timeToKeepSec = $secondsToKeep;
				mutable boolean needsNewestTimeInformation = true;
				mutable int64 newestTimeInformation = 0l;
			}
			onTuple I:
			{
				if (needsNewestTimeInformation)
				{
					needsNewestTimeInformation = false;
					newestTimeInformation = getSeconds(getTimestamp());
				}
				appTrc(Trace.trace, (rstring)I + "---" + (rstring)newestTimeInformation + "---" + (rstring)(newestTimeInformation - I.fileModificationTime_secs) + "---" + (rstring)timeToKeepSec);
			}
			onPunct I:
			{
				needsNewestTimeInformation = true;
			}
			param filter: (newestTimeInformation - I.fileModificationTime_secs) < timeToKeepSec;
		}

		/**
		 * Remove too old files.
		 */
		@spl_category(name="sample") 
		() as Remover = Custom(TooOld as I)
		{
			logic
			state:
			{
				mutable int32 removeResult = 0;
			}
			onTuple I:
			{
				spl.file::remove (I.filePath, removeResult);
				if (0 != removeResult)
				{
					appTrc(Trace.error, "cannot remove file: " + (rstring)I + ", reason: " + strerror(removeResult));
				}
				else
				{
					appTrc(Trace.trace, "removed file: " + (rstring)I);
				}
			}
		}

}
<%} #endif enabled%>
