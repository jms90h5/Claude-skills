// begin_generated_IBM_copyright_prolog                            
//                                                                 
// This is an automatically generated copyright prolog.            
// After initializing,  DO NOT MODIFY OR MOVE                      
// ****************************************************************
// Licensed Materials - Property of IBM                            
// 5724-Y95                                                        
// (C) Copyright IBM Corp.  2011, 2025    All Rights Reserved.     
// US Government Users Restricted Rights - Use, duplication or     
// disclosure restricted by GSA ADP Schedule Contract with         
// IBM Corp.                                                       
//                                                                 
// end_generated_IBM_copyright_prolog                              
// begin_generated_IBM_Teracloud_ApS_copyright_prolog               
//                                                                  
// This is an automatically generated copyright prolog.             
// After initializing,  DO NOT MODIFY OR MOVE                       
// **************************************************************** 
// Licensed Materials - Property of IBM                             
// (C) Copyright Teracloud ApS 2024, 2025, IBM Corp. 2023, 2023     
// All Rights Reserved.                                             
// US Government Users Restricted Rights - Use, duplication or      
// disclosure restricted by GSA ADP Schedule Contract with          
// IBM Corp.                                                        
//                                                                  
// end_generated_IBM_Teracloud_ApS_copyright_prolog                 
<% # Switch to Perl scripting mode
	use integer;
	use File::Basename ;
	use File::Spec::Functions qw(catfile catdir) ;
	use FindBin;
	my $toProj=2;
	my $projDir = dirname(__FILE__);
	for (my $i = 0; $i<$toProj; $i++) {
		$projDir=dirname($projDir);
		$projDir=~s/\/$//;
	}
	unshift @INC, catdir($projDir,"scripts");
	require Configurator;
	require CodeGenFrw;
	my $configurator = new Configurator(directory => "$projDir", selector => Configurator::ParameterSet::ITE());
	my $curDir = $projDir;

	# -------------------------------------------------------------------------
	# Get mandatory application specific configuration parameters
	# -------------------------------------------------------------------------
	my $contextDisabled = $configurator->isOff(Configurator::ITE_BUSINESSLOGIC_GROUP());
	my $dedupDisabled = $contextDisabled || $configurator->isOff(Configurator::ITE_BUSINESSLOGIC_GROUP_DEDUPLICATION());
	my $isPartitioningEnabledForTupleDeduplication = !$dedupDisabled && $configurator->isOn(Configurator::ITE_BUSINESSLOGIC_GROUP_DEDUPLICATION_PARTITIONING());	
	
	my $FILEINGESTION_LEVEL1_SPLIT_DISABLED = $configurator->isOff(Configurator::ITE_INGEST_FILEGROUPSPLIT());
	my $TRANSFORMER_LEVEL1_SPLIT = $configurator->isOn(Configurator::ITE_BUSINESSLOGIC_TRANSFORMATION_TUPLEGROUPSPLIT());
	
	my $numGroups = 0;
	if ((0 == $contextDisabled) && (0 == $dedupDisabled)) {
		my $chainCfgFile = $curDir."/".$configurator->getString(Configurator::ITE_INGEST_LOADDISTRIBUTION_GROUPCONFIGFILE());
		$numGroups = CodeGenFrw::getNumGroups($chainCfgFile);
		print("//\t\t[GROUPSS=$numGroups]\n");
	}
	# -------------------------------------------------------------------------
%>
namespace demoapp.chainsink;

<%if ((0 == $contextDisabled) && (0 == $dedupDisabled)) {%>
use demoapp.streams::*;
use com.teracloud.streams.teda.file::rename;

/**
 * HashFileWriterCore
 * Writes hash codes to files
 *
 * @input  InHash Tuples for HashCode File Sink
 * @input  InMove Move trigger for HashCode files
 * 
 * @param checkpointDir
 * Output directory of hash code files
 */
public composite HashFileWriterCore (
	input 
		InHash,
		InMove
)
{
	param
		expression<rstring> $checkpointDir;

	graph

	<%if ( (0 == $contextDisabled) && (1 == $FILEINGESTION_LEVEL1_SPLIT_DISABLED) && (1 == $TRANSFORMER_LEVEL1_SPLIT) ) {%>

		// Context (Level1ID) Split
		@spl_category(name="common")
		(
		<%=join(";\n\t\t",map { 'stream<InHash> OutHashSplit_'.CodeGenFrw::l0($_); }(0..$numGroups-1))%>
		) = Custom(InHash; InMove) {
			logic
				state : {
					mutable map<rstring,rstring> hashFilesMap; // key: groupId, value: filename
					rstring dir = $checkpointDir; // prevents submission code to be called when using directory param
				}
				onTuple InHash : {
					if (!(groupId in hashFilesMap)) {
						mutable rstring hashFilename=filename+"<%=CodeGenFrw::getConstant('HASH_FILE_EXTENSION')%>";
						hashFilesMap[groupId] = hashFilename;
					}
					// send to correct output port
					if ("00" == groupId) {submit(InHash, OutHashSplit_00);}
					<%for (my $i=1; $i<$numGroups; $i++) {%>
					else if ("<%=CodeGenFrw::l0($i)%>" == groupId) {submit(InHash, OutHashSplit_<%=CodeGenFrw::l0($i)%>);}
					<%}%>
				}
				onTuple InMove : {
					if (InMove.move) {
	 					for (rstring hcFileLevel1Id in hashFilesMap) {
							mutable int32 err=0;
							mutable rstring oldname=dir+"/"+hcFileLevel1Id+"/"+hashFilesMap[hcFileLevel1Id];
							mutable rstring newname=dir+"/"+hcFileLevel1Id+"/<%=CodeGenFrw::getConstant('COMMIT_DIR')%>/"+hashFilesMap[hcFileLevel1Id];
							rename(oldname, newname, err);
						}
					}
					// clear the list
					clearM(hashFilesMap);
				}
				onPunct InHash: {
						// forward to all output port
						<%for (my $i=0; $i<$numGroups; $i++) {%>
						submit(Sys.WindowMarker, OutHashSplit_<%=CodeGenFrw::l0($i)%>);
						<%}%>
				}
		}

		<%for (my $i=0; $i<$numGroups; $i++) {%>
		@spl_category(name="common")
		() as HashCodesSink_<%=CodeGenFrw::l0($i)%> = FileSink(OutHashSplit_<%=CodeGenFrw::l0($i)%>) {
			logic
				state : {
					rstring dir = $checkpointDir; // prevents submission code to be called when using directory param
				}
			param
				file : dir+"/"+groupId+"/"+filename+"<%=CodeGenFrw::getConstant('HASH_FILE_EXTENSION')%>";
				format: csv;
				flushOnPunctuation: true;
				closeMode: punct;
				append: false;
				quoteStrings : false;
				suppress: filename,groupId<%unless (1 == $isPartitioningEnabledForTupleDeduplication) {%>,partitionId<%}%>;
		}
		<%}%>
		
	<%} else { %>
		// Constant Level1ID
		@spl_category(name="common")
		(
		stream<InHash> OutHash
		) = Custom(InHash; InMove) {
			logic
				state : {
					rstring dir = $checkpointDir; // prevents submission code to be called when using directory param
					mutable rstring hashFilename;
					mutable rstring hcFileLevel1Id;
				}
				onTuple InHash : {
					hashFilename=filename+"<%=CodeGenFrw::getConstant('HASH_FILE_EXTENSION')%>";
					hcFileLevel1Id=groupId;
					// send to file sink
					submit(InHash, OutHash);
				}
				onTuple InMove : {
					if ((InMove.move) && ("" != hashFilename))  {
						mutable int32 err=0;
						mutable rstring oldname=dir+"/"+hcFileLevel1Id+"/"+hashFilename;
						mutable rstring newname=dir+"/"+hcFileLevel1Id+"/<%=CodeGenFrw::getConstant('COMMIT_DIR')%>/"+hashFilename;
						rename(oldname, newname, err);
					}
					// reset the filename
					hashFilename="";
				}
				onPunct InHash: {
					submit(Sys.WindowMarker, OutHash);
				}
		}

		@spl_category(name="common")
		() as HashCodesSink = FileSink(OutHash) {
			logic
				state : {
					rstring dir = $checkpointDir; // prevents submission code to be called when using directory param
				}
			param
				file : dir+"/"+groupId+"/"+filename+"<%=CodeGenFrw::getConstant('HASH_FILE_EXTENSION')%>";
				format: csv;
				flushOnPunctuation: true;
				closeMode: punct;
				append: false;
				quoteStrings : false;
				suppress: filename,groupId<%unless (1 == $isPartitioningEnabledForTupleDeduplication) {%>,partitionId<%}%>;
		}
	<%}%>
		
}
<%} #endif dedup disabled%>
