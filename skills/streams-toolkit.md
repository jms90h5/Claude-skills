# Streams Toolkit Generator

## Description
This skill helps you create IBM Streams toolkits - reusable collections of operators, functions, and types that can be shared across multiple Streams applications. Toolkits are the primary way to package and distribute Streams functionality.

## What this skill does
- Creates complete toolkit directory structure
- Generates toolkit.xml configuration file
- Sets up namespaces and operators
- Creates build files and documentation
- Follows IBM Streams toolkit best practices

## Usage
Ask questions like:
- "Create a Streams toolkit for data transformation"
- "Generate a toolkit with Java and C++ operators"
- "Create a toolkit that wraps a REST API"
- "Build a toolkit for machine learning operations"

## Toolkit Structure

### Complete Toolkit Directory Layout
```
com.company.toolkit/
├── toolkit.xml                    # Toolkit metadata
├── info.xml                       # Toolkit information (optional)
├── Makefile                       # Build configuration
│
├── com.company.namespace/         # SPL namespace directories
│   ├── Operator1/                 # Primitive operator
│   │   └── Operator1.xml          # Operator model
│   ├── Operator2/
│   │   └── Operator2.xml
│   ├── Composite1.spl             # Composite operator
│   ├── Composite2.spl
│   └── types.spl                  # Type definitions
│
├── impl/                          # Implementation files
│   ├── java/                      # Java implementations
│   │   ├── src/
│   │   │   └── com/company/operators/
│   │   │       ├── Operator1.java
│   │   │       └── Operator2.java
│   │   └── build.xml              # Ant build file
│   ├── cpp/                       # C++ implementations
│   │   ├── src/
│   │   │   ├── Operator3.cpp
│   │   │   └── Helper.cpp
│   │   ├── include/
│   │   │   ├── Operator3.h
│   │   │   └── Helper.h
│   │   └── Makefile
│   └── python/                    # Python implementations (optional)
│       └── ...
│
├── lib/                           # Compiled libraries
│   ├── liboperators.so            # C++ library
│   └── operators.jar              # Java JAR
│
├── etc/                           # Configuration files
│   ├── config.properties
│   └── schemas/
│       └── message.xsd
│
├── opt/                           # Optional resources
│   ├── python/                    # Python operators
│   │   └── streams/
│   │       └── operators.py
│   ├── resources/                 # Resource files
│   └── samples/                   # Sample data
│
├── doc/                           # Documentation
│   ├── spldoc/                    # Generated SPL documentation
│   └── README.md
│
└── samples/                       # Sample applications
    └── SampleApp/
        ├── Main.spl
        └── Makefile
```

## toolkit.xml - Core Configuration

The `toolkit.xml` file is automatically generated by the SPL compiler, but you need to understand its structure:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<toolkitModel
  xmlns="http://www.ibm.com/xmlns/prod/streams/spl/toolkit"
  productVersion="4.3.0.0"
  xmlns:common="http://www.ibm.com/xmlns/prod/streams/spl/common"
  xmlns:ti="http://www.ibm.com/xmlns/prod/streams/spl/toolkitInfo"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <toolkit name="com.company.toolkit" requiredProductVersion="4.0.0" version="1.0.0">
    <description>Description of the toolkit</description>

    <!-- Dependencies on other toolkits -->
    <dependency>
      <common:name>com.teracloud.streams.json</common:name>
      <common:version>[2.0.0,3.0.0)</common:version>
    </dependency>

    <!-- Namespaces and operators are listed here (auto-generated) -->
    <namespace name="com.company.namespace">
      <primitiveOp language="Java" modelUriIndex="1" name="Operator1" public="true">
        <description>Operator description</description>
      </primitiveOp>
      <compositeOp column="1" line="1" name="Composite1" potentialMain="false" uriIndex="2"/>
    </namespace>

    <!-- Resources to include in toolkit archive -->
    <sabFiles>
      <ti:include path="toolkit.xml" root="toolkitDir"/>
      <ti:include path="impl/java/lib/**" root="toolkitDir"/>
      <ti:include path="impl/lib/**" root="toolkitDir"/>
      <ti:include path="lib/**" root="toolkitDir"/>
      <ti:include path="etc/**" root="toolkitDir"/>
      <ti:include path="opt/**" root="toolkitDir"/>
    </sabFiles>
  </toolkit>
</toolkitModel>
```

## info.xml - Toolkit Metadata

```xml
<?xml version="1.0" encoding="UTF-8"?>
<info:toolkitInfoModel
  xmlns:common="http://www.ibm.com/xmlns/prod/streams/spl/common"
  xmlns:info="http://www.ibm.com/xmlns/prod/streams/spl/toolkitInfo">

  <info:identity>
    <info:name>com.company.toolkit</info:name>
    <info:description>
      Comprehensive description of what this toolkit provides.
      This appears in the Streams Studio and documentation.
    </info:description>
    <info:version>1.0.0</info:version>
    <info:requiredProductVersion>4.0.0</info:requiredProductVersion>
  </info:identity>

  <info:dependencies>
    <info:toolkit>
      <common:name>com.teracloud.streams.json</common:name>
      <common:version>[2.0.0,3.0.0)</common:version>
    </info:toolkit>
  </info:dependencies>

  <info:resources>
    <info:messageSet name="MyToolkitMessages">
      <info:lang default="true">en_US/MyToolkitMessages.xlf</info:lang>
    </info:messageSet>
  </info:resources>
</info:toolkitInfoModel>
```

## Top-Level Makefile

```makefile
.PHONY: all clean toolkit java cpp python samples doc

# Toolkit information
TOOLKIT_NAME = com.company.toolkit
STREAMS_INSTALL = $(STREAMS_INSTALL)
SPLC = $(STREAMS_INSTALL)/bin/sc
SPLC_FLAGS = -a

# Paths
IMPL_JAVA_DIR = impl/java
IMPL_CPP_DIR = impl/cpp
LIB_DIR = lib
SAMPLES_DIR = samples

all: toolkit

toolkit: java cpp python
	@echo "Building toolkit..."
	$(SPLC) $(SPLC_FLAGS) -M $(TOOLKIT_NAME) --no-mixed-mode-preprocessing
	@echo "Toolkit build complete"

java:
	@echo "Building Java operators..."
	@if [ -d "$(IMPL_JAVA_DIR)" ]; then \
		cd $(IMPL_JAVA_DIR) && ant; \
	fi

cpp:
	@echo "Building C++ operators..."
	@if [ -d "$(IMPL_CPP_DIR)" ]; then \
		cd $(IMPL_CPP_DIR) && $(MAKE); \
	fi

python:
	@echo "Python operators don't need compilation"

samples:
	@echo "Building sample applications..."
	@for dir in $(SAMPLES_DIR)/*; do \
		if [ -d "$$dir" ]; then \
			echo "Building $$dir..."; \
			cd $$dir && $(MAKE) && cd ../..; \
		fi \
	done

doc:
	@echo "Generating documentation..."
	$(SPLC) -M $(TOOLKIT_NAME) --doc

clean:
	@echo "Cleaning toolkit..."
	$(SPLC) $(SPLC_FLAGS) -C -M $(TOOLKIT_NAME)
	@if [ -d "$(IMPL_JAVA_DIR)" ]; then \
		cd $(IMPL_JAVA_DIR) && ant clean; \
	fi
	@if [ -d "$(IMPL_CPP_DIR)" ]; then \
		cd $(IMPL_CPP_DIR) && $(MAKE) clean; \
	fi
	rm -rf output
	rm -rf doc/spldoc
	@echo "Clean complete"

install:
	@echo "Installing toolkit to $(STREAMS_INSTALL)/toolkits/$(TOOLKIT_NAME)"
	@mkdir -p $(STREAMS_INSTALL)/toolkits
	@rm -rf $(STREAMS_INSTALL)/toolkits/$(TOOLKIT_NAME)
	@cp -r . $(STREAMS_INSTALL)/toolkits/$(TOOLKIT_NAME)
	@echo "Installation complete"
```

## Namespace Organization

### SPL Types File (com.company.namespace/types.spl)
```spl
namespace com.company.namespace;

/**
 * Message type for data exchange
 */
type Message = rstring key, rstring value, timestamp ts;

/**
 * Configuration type
 */
type Config = rstring host, int32 port, boolean secure;

/**
 * Status codes
 */
type Status = enum { OK, ERROR, TIMEOUT, UNKNOWN };
```

### Composite Operators (com.company.namespace/MyComposite.spl)
```spl
namespace com.company.namespace;

/**
 * Composite operator that encapsulates common processing pattern
 */
public composite ProcessData(input In; output Out)
{
    param
        expression<rstring> $filter : ".*";
        expression<int32> $batchSize : 100;

    graph
        stream<In> Filtered = Filter(In)
        {
            param
                filter: matches(data, $filter);
        }

        stream<In> Batched = Aggregate(Filtered)
        {
            window
                Filtered: tumbling, count($batchSize);
            output
                Batched: data = Last(data);
        }

        stream<In> Out = Custom(Batched)
        {
            logic
                onTuple Batched:
                {
                    // Custom processing
                    submit(Batched, Out);
                }
        }
}
```

## Toolkit Versioning

Follow Semantic Versioning (MAJOR.MINOR.PATCH):
- **MAJOR**: Incompatible API changes
- **MINOR**: Add functionality in backward-compatible manner
- **PATCH**: Backward-compatible bug fixes

Example versions:
- 1.0.0 - Initial release
- 1.1.0 - Added new operators
- 1.1.1 - Bug fixes
- 2.0.0 - Breaking changes

## Toolkit Dependencies

Specify version ranges in toolkit.xml:
```xml
<dependency>
    <common:name>com.teracloud.streams.kafka</common:name>
    <!-- Exact version -->
    <common:version>3.0.0</common:version>
</dependency>

<dependency>
    <common:name>com.teracloud.streams.json</common:name>
    <!-- Version range: >= 2.0.0 and < 3.0.0 -->
    <common:version>[2.0.0,3.0.0)</common:version>
</dependency>

<dependency>
    <common:name>com.teracloud.streams.hdfs</common:name>
    <!-- Minimum version -->
    <common:version>4.0.0,)</common:version>
</dependency>
```

## Testing Your Toolkit

### Create Test Application
```spl
// samples/TestApp/Main.spl
namespace test;

use com.company.namespace::*;

composite TestApp {
    graph
        stream<Message> Data = MySource() {
            param
                iterations: 100;
        }

        stream<Message> Processed = MyOperator(Data) {
        }

        () as Sink = FileSink(Processed) {
            param
                file: "output.txt";
        }
}
```

### Test Makefile
```makefile
# samples/TestApp/Makefile
.PHONY: all clean

SPLC_FLAGS = -a -t ../../..
SPLC = sc

all:
	$(SPLC) $(SPLC_FLAGS) -M test::TestApp

clean:
	$(SPLC) $(SPLC_FLAGS) -C -M test::TestApp
	rm -rf output

run:
	output/bin/standalone
```

## Packaging and Distribution

### Create Toolkit Archive
```bash
# Index the toolkit
sc -M com.company.toolkit

# Create archive
cd ..
tar czf com.company.toolkit-1.0.0.tar.gz com.company.toolkit/
```

### Using the Toolkit
Users can reference your toolkit by:

1. **Environment variable:**
```bash
export STREAMS_SPLPATH=/path/to/toolkits:$STREAMS_SPLPATH
```

2. **Compiler flag:**
```bash
sc -t /path/to/com.company.toolkit -M my.app::Main
```

3. **Install to Streams:**
```bash
cp -r com.company.toolkit $STREAMS_INSTALL/toolkits/
```

## Documentation

### Generate SPLDoc
```bash
# Generate HTML documentation
sc -M com.company.toolkit --doc

# Documentation will be in doc/spldoc/html/
```

### Add Operator Documentation
Use special comments in SPL:
```spl
/**
 * Process incoming messages and apply transformation.
 *
 * This operator receives messages, validates them, and applies
 * a configured transformation before forwarding.
 *
 * @param filter Regular expression to filter messages
 * @param timeout Timeout in seconds for processing
 *
 * @input Input Input port for raw messages
 * @output Output Output port for processed messages
 */
public composite MyComposite(input Input; output Output)
{
    // ...
}
```

## Multi-Language Toolkit Example

### Complete Mixed-Language Toolkit

```
com.company.analytics/
├── toolkit.xml
├── info.xml
├── Makefile
│
├── com.company.analytics/
│   ├── types.spl                      # Common types
│   ├── DataSource.spl                 # Composite operators
│   ├── JavaFilter/                    # Java operator
│   │   └── JavaFilter.xml
│   ├── CppTransform/                  # C++ operator
│   │   ├── CppTransform.xml
│   │   ├── CppTransform_h.cgt
│   │   └── CppTransform_cpp.cgt
│   └── PythonPredictor/              # Will be in opt/python
│
├── impl/
│   ├── java/
│   │   ├── src/com/company/analytics/
│   │   │   └── JavaFilter.java
│   │   └── build.xml
│   └── cpp/
│       ├── src/
│       │   └── CppTransform.cpp
│       ├── include/
│       │   └── CppTransform.h
│       └── Makefile
│
├── opt/
│   └── python/
│       └── streams/
│           └── analytics.py          # Python operators
│
└── lib/
    ├── analytics.jar
    └── libanalytics.so
```

## Best Practices

1. **Naming Conventions**:
   - Toolkit name: `com.company.functionality`
   - Use reverse domain notation
   - Be descriptive but concise

2. **Versioning**:
   - Follow semantic versioning
   - Document breaking changes
   - Maintain backward compatibility when possible

3. **Organization**:
   - Group related operators in same namespace
   - Separate public and internal namespaces
   - Keep implementation files organized by language

4. **Documentation**:
   - Add comprehensive SPLDoc comments
   - Include README.md with usage examples
   - Provide sample applications

5. **Testing**:
   - Create sample applications
   - Test all operators
   - Verify different deployment scenarios

6. **Performance**:
   - Profile operators
   - Minimize tuple copies
   - Use appropriate operator languages (C++ for performance, Java for ease, Python for prototyping)

7. **Dependencies**:
   - Minimize external dependencies
   - Document required libraries
   - Use version ranges wisely

8. **Maintenance**:
   - Keep code clean and well-commented
   - Use version control
   - Maintain changelog

## Documentation References

### HTML Documentation
See streams_docs/com.ibm.streams.dev.doc/doc/ for detailed documentation:
- `toolkits.html` - Toolkit overview
- `creating_toolkits.html` - Creating toolkits guide
- `toolkitstructure.html` - Toolkit structure
- `toolkitinformationmodelfile.html` - toolkit.xml reference
- `versioningguidelines.html` - Versioning guidelines
- `packagingatoolkit.html` - Packaging guide

### IBM Redbooks
The streams_docs directory includes comprehensive IBM Redbooks:

- **Stream1.0Redbook_sg248108.pdf** - IBM Streams Version 1.0 Redbook
  - Toolkit architecture and design patterns
  - Creating reusable operator libraries
  - Toolkit organization and structure
  - Dependency management

- **Streams2.0Redbook.pdf** - IBM Streams Version 2.0 Redbook
  - Advanced toolkit development techniques
  - Multi-language toolkit patterns
  - Toolkit versioning and maintenance
  - Distribution and deployment strategies
  - Real-world toolkit examples and case studies

These Redbooks provide comprehensive guidance on creating professional, production-ready Streams toolkits.

## Instructions

When the user asks to create a Streams toolkit:

1. Ask clarifying questions:
   - What is the toolkit's purpose?
   - What operators should it include?
   - What languages (Java/C++/Python)?
   - Any external dependencies?
   - Who will use it?

2. Generate the toolkit:
   - Create directory structure
   - Generate toolkit.xml and info.xml
   - Create Makefiles
   - Set up namespaces
   - Add operator placeholders
   - Create sample application

3. Explain the structure:
   - Describe organization
   - Explain build process
   - Show how to add operators
   - Demonstrate usage

4. Provide next steps:
   - How to build
   - How to test
   - How to document
   - How to package and distribute
